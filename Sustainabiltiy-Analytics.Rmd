---
title: "Evaluation of Variable Renewable Energy Source's 
contribution to cost of control energy"
author: "Del Conte, Küng, van Lengerich, Vayloyan "
date: "2024-08-03"
output:
  pdf_document:
    toc: yes
    toc_depth: 2
    number_sections: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
notes: footnotes
---

```{r, load libraries, include = F, warning = F}
library(knitr)
library(readxl) #install packages first if not done so already
library(readr)
library(tidyr)
library(tidyquant)
library(lubridate)
library(ggplot2)
library(forecast)
library(tseries)
library(rugarch)
library(vars)
library(scales)
library(dplyr)
library(readr)
library(stringr)

setwd(dirname(rstudioapi::getSourceEditorContext()$path)) #setting directory
```

```{r, importing power prices, warning = F, include= F, cache= T}
sheets_after_2015 <- c("EnergieUebersichtCH-2015.xls",
                       "EnergieUebersichtCH-2016.xls", 
                       "EnergieUebersichtCH-2017.xls",
                       "EnergieUebersichtCH-2018.xls", 
                       "EnergieUebersichtCH-2019.xls",
                       "EnergieUebersichtCH-2020.xls"
                       )

sheets_after_2021 <- c("EnergieUebersichtCH-2021.xlsx",
                       "EnergieUebersichtCH-2022.xlsx",
                       "EnergieUebersichtCH-2023.xlsx",
                       "EnergieUebersichtCH-2024.xlsx"
                       )

# Empty list to store data frames
data_list <- list()

# Loop through the sheets and read each one for xls
for (s in sheets_after_2015) {
  # Read the Excel file
  df <- read_xls(s, sheet = "Zeitreihen0h15",)
  df <- df %>% select(1, 7,8,9,10, 22:25) 
  
  # Convert the timestamp column
  df[[1]] <- as.numeric(df[[1]])
  df$Timestamp <- as.POSIXct(df[[1]] * 86400,
                             origin = "1899-12-29 23:00:00",
                             tz = "Europe/Zurich")
  
  # Store the data frame in the list
  data_list[[s]] <- df %>% select(-1)
}

# Loop through the sheets and read each one for xlsx
for (s in sheets_after_2021) {
  # Read the Excel file
  df <- read_xlsx(s, sheet = "Zeitreihen0h15",)
  df <- df %>% select (1, 7,8,9,10, 22:25) 
  
  # Convert the timestamp column
  df$Timestamp <- as.POSIXct(df[[1]],
                             format = "%d.%m.%Y %H:%M",
                             tz = "Europe/Zurich")
  
  #remove first column
  df <- df %>% select(-1)
  
  # Set the column-names to match the xls data
  # Adjusting the slightly different spelling
  colnames(df) <- 
    colnames(data_list[["EnergieUebersichtCH-2015.xls"]])
  
  # Store the data frame in the list
  data_list[[s]] <- df
}

# Combine all data frames in the list into one
combined_data <- bind_rows(data_list)

combined_data <- combined_data %>% 
  filter(combined_data[[2]] != "kWh") # taking out the duplicated headers which
                                      # ended up in the dataframe
```

```{r, manipulations 1, warning = F, include= F, cache= T}
combined_data <- combined_data %>% 
  rename(
    pos_sec_amount_kwh = names(combined_data)[1], 
    neg_sec_amount_kwh = names(combined_data)[2],
    pos_ter_amount_kwh = names(combined_data)[3],
    neg_ter_amount_kwh = names(combined_data)[4],
    price_pos_sec_EUR_MWh = names(combined_data)[5],
    price_neg_sec_EUR_MWh = names(combined_data)[6],
    price_pos_ter_EUR_MWh = names(combined_data)[7],
    price_neg_ter_EUR_MWh = names(combined_data)[8]
    ) 

combined_data <- combined_data %>% 
    mutate(across(c(1:8), as.numeric)) # convert to numeric

combined_data <- combined_data %>% 
  mutate( #calculating costs of energy
  cost_pos_sec = (combined_data[[1]] / 1000)*combined_data[[5]], 
  cost_neg_sec = (combined_data[[2]] / 1000)*combined_data[[6]],  
  cost_pos_ter = (combined_data[[3]] / 1000)*combined_data[[7]],
  cost_neg_ter = (combined_data[[4]] / 1000)*combined_data[[8]]
  ) %>% 
  select(9, everything())  #rearranging
```


```{r, manipulations 2, warning = F, include= F, cache= T}
hourly_summary <- combined_data %>%
  # create a column 'hour' by rounding down to the nearest hour
  mutate(hour = floor_date(Timestamp, "hour")) %>%  
  group_by(hour) %>%  # Group by the new 'hour' column
  summarise(
    # Sum the energy amount columns
    pos_sec_amount_kwh = sum(pos_sec_amount_kwh, na.rm = TRUE),
    neg_sec_amount_kwh = sum(neg_sec_amount_kwh, na.rm = TRUE),
    pos_ter_amount_kwh = sum(pos_ter_amount_kwh, na.rm = TRUE),
    neg_ter_amount_kwh = sum(neg_ter_amount_kwh, na.rm = TRUE),

    # Sum the cost columns
    cost_pos_sec = sum(cost_pos_sec, na.rm = TRUE),
    cost_neg_sec = sum(cost_neg_sec, na.rm = TRUE),
    cost_pos_ter = sum(cost_pos_ter, na.rm = TRUE),
    cost_neg_ter = sum(cost_neg_ter, na.rm = TRUE),

    # Average the price columns
    avg_price_pos_sec_EUR_MWh = mean(price_pos_sec_EUR_MWh, na.rm = TRUE),
    avg_price_neg_sec_EUR_MWh = mean(price_neg_sec_EUR_MWh, na.rm = TRUE),
    avg_price_pos_ter_EUR_MWh = mean(price_pos_ter_EUR_MWh, na.rm = TRUE),
    avg_price_neg_ter_EUR_MWh = mean(price_neg_ter_EUR_MWh, na.rm = TRUE)
  ) %>%
  ungroup() %>%   # Ungroup to complete the operation
  rename(
  Timestamp    = hour #renaming for merging
  )
```


```{r, importing renwable share and grid load, include = F , warning = F, include= F}
# Importing the generation data per production type
gen_per_type_list <- c("Actual Generation per Production Type_201501010000-201601010000.csv",
                       "Actual Generation per Production Type_201601010000-201701010000.csv",
                       "Actual Generation per Production Type_201701010000-201801010000.csv",
                       "Actual Generation per Production Type_201801010000-201901010000.csv",
                       "Actual Generation per Production Type_201901010000-202001010000.csv",
                       "Actual Generation per Production Type_202001010000-202101010000.CSV",
                       "Actual Generation per Production Type_202101010000-202201010000.csv",
                       "Actual Generation per Production Type_202201010000-202301010000.csv",
                       "Actual Generation per Production Type_202301010000-202401010000.csv",
                       "Actual Generation per Production Type_202401010000-202501010000.csv")

# Initialize an empty dataframe to store the combined data
df_combined_type <- tibble()

# Loop through the different csv
for (s in gen_per_type_list) {
  # Read the csv
  df_gen_per_type <- read_csv(s, na = c("N/A", "", "n/e", "-"))
  
  # Combine the dataframes
  df_combined_type <- bind_rows(df_combined_type, df_gen_per_type)
  }

# Importing the grid load data
grid_load_list <- c("Total Load - Day Ahead _ Actual_201501010000-201601010000.csv",
                    "Total Load - Day Ahead _ Actual_201601010000-201701010000.csv",
                    "Total Load - Day Ahead _ Actual_201701010000-201801010000.csv",
                    "Total Load - Day Ahead _ Actual_201801010000-201901010000.csv",
                    "Total Load - Day Ahead _ Actual_201901010000-202001010000.csv",
                    "Total Load - Day Ahead _ Actual_202001010000-202101010000.csv",
                    "Total Load - Day Ahead _ Actual_202101010000-202201010000.csv",
                    "Total Load - Day Ahead _ Actual_202201010000-202301010000.csv",
                    "Total Load - Day Ahead _ Actual_202301010000-202401010000.csv",
                    "Total Load - Day Ahead _ Actual_202401010000-202501010000.csv")

# Initialize an empty dataframe to store the combined data
df_combined_load <- tibble()

# Loop through the different csv
for (s in grid_load_list) {
  # Read the csv
  df_load <- read_csv(s, na = c("N/A", "", "n/e", "-"))
  
  # Combine the dataframes
  df_combined_load <- bind_rows(df_combined_load, df_load)
  }


# Create timestamps for the dataframe (per type)
df_combined_type <- df_combined_type %>%
  mutate(
    # Extract the starting date-time part of the MTU column
    StartTimestamp = sapply(str_split(MTU, " - "), `[`, 1),
    Timestamp = suppressWarnings(
      dmy_hm(StartTimestamp, tz = "Europe/Zurich"))
    ) %>%
  select(-StartTimestamp) %>% 
  # Remove rows where Timestamp is NA (problem with daylight savings time)
  filter(!is.na(Timestamp)) %>% 
  # Remove duplicate rows (there are duplicate rows because of daylight savings 
  # time (time from 02:00 to 03:00 happens twice) -> only keep the first row)
  distinct(Timestamp, .keep_all = TRUE)


# Create timestamps for the dataframe (load)
df_combined_load <- df_combined_load %>%
  mutate(
    # Extract the starting date-time part of the MTU column
    StartTimestamp = sapply(str_split(`Time (CET/CEST)`, " - "), `[`, 1),
    Timestamp = suppressWarnings(
      dmy_hm(StartTimestamp, tz = "Europe/Zurich"))
    ) %>%
  select(-StartTimestamp) %>% 
  # Remove rows where Timestamp is NA (problem with daylight savings time)
  filter(!is.na(Timestamp)) %>% 
  # Remove duplicate rows (there are duplicate rows because of daylight savings 
  # time (time from 02:00 to 03:00 happens twice) -> only keep the first row)
  distinct(Timestamp, .keep_all = TRUE)


# Merging two combined dataframes on the timestamp
df_gen_load_raw <- full_join(df_combined_type, df_combined_load,
               by = "Timestamp") 


# Clean up combined df
df_gen_load <- df_gen_load_raw %>% 
  # Remove columns where all values are NAs (Fossil - brown coal for example)
  select(where(~ any(!is.na(.)))) %>% 
  # Remove column are (CH)
  # Remove columns conatining original time information and area
  select(-c("Area", "MTU", "Time (CET/CEST)"))

# Adding VRES (percentage Swiss (solar + wind) production / load on grid)
df_gen_load <- df_gen_load %>%
  mutate(VRES_percent = (`Solar  - Actual Aggregated [MW]` + `Wind Onshore  - Actual Aggregated [MW]`) / `Actual Total Load [MW] - BZN|CH`)
```


```{r, join, include= F, warning = F }
df_combined <- left_join(hourly_summary, df_gen_load, by = "Timestamp") 
# merging on the hour
```


```{r, adding total cost, include = F, warning = F}
# Add total cost
df_combined <- df_combined %>% 
  #calculating total cost by summing all costs
  mutate(total_cost_EUR = 
           cost_pos_sec+cost_neg_sec+cost_pos_ter+cost_neg_ter)

# Save the lines with NA values in VRES or Total cost -> 57 lines / hours
df_na_output <- df_combined %>% 
  filter(is.na(VRES_percent) | is.na(total_cost_EUR))

# Exclude the lines with NA values in VRES or Total cost
df_combined <- df_combined %>% 
  filter(!is.na(VRES_percent) & !is.na(total_cost_EUR)) 

# Rearrange and rename rows in df_combined
d.h <- df_combined %>% 
  select(Timestamp, VRES_percent, total_cost_EUR,
         total_load_MW = `Actual Total Load [MW] - BZN|CH`,
         cost_pos_sec_EUR = cost_pos_sec, cost_neg_sec_EUR = cost_neg_sec,
         cost_pos_ter_EUR = cost_pos_ter, cost_neg_ter_EUR = cost_neg_ter,
         pos_sec_amount_kwh, neg_sec_amount_kwh,
         pos_ter_amount_kwh, neg_ter_amount_kwh,
         avg_price_pos_sec_EUR_MWh, avg_price_neg_sec_EUR_MWh,
         avg_price_pos_ter_EUR_MWh, avg_price_neg_ter_EUR_MWh,
         CH_solar_generation_actual_MW = `Solar  - Actual Aggregated [MW]`,
         CH_wind_onshore_generation_actual_MW =
           `Wind Onshore  - Actual Aggregated [MW]`,
         everything())

# removing clutter
remove(combined_data, data_list, df, df_load, df_combined,
       df_combined_load, df_combined_type, 
       df_gen_load, df_gen_per_type, hourly_summary)
```


```{r, Test cost of 2020, warning = F, include= F}
sums_2020 <- d.h %>%
    filter(year(Timestamp) == 2020) %>%
    summarise(across(where(is.numeric), ~ sum(.x, na.rm = FALSE)))
# Comparison with report shows same numbers
```


```{r, daily-data_load, include = F, warning = F}
# Load the datasets
energy_production <- read_csv("ogd104_stromproduktion_swissgrid.csv")
energy_prices <- read_csv("ogd106_preise_strom_boerse.csv")

# Reshape the energy production data to have one column per energy source
energy_production <- energy_production %>%
  pivot_wider(names_from = Energietraeger, values_from = Produktion_GWh, values_fill = 0)

# Merge the reshaped energy production data with the energy prices data
d.d <- merge(energy_prices, energy_production, by="Datum", all.x=TRUE)

# Fill any remaining NAs with 0 (in case there were dates in energy_prices not in energy_production)
d.d[is.na(d.d)] <- 0
```

```{r, daily-data_rename variables, include = F, warning = F}

# Rename columns in dataset
d.d <- d.d %>%
  rename(
    Date = Datum,
    Hydro_GWh = Flusskraft,
    Nuclear_GWh = Kernkraft,
    Storage_GWh = Speicherkraft,
    Thermal_GWh = Thermische,
    Photovoltaic_GWh = Photovoltaik,
    Wind_GWh = Wind
  )
```

```{r, daily_data-add vres and non-vres, include = F, warning = F}

# Add new columns 'VRES_GWh' and 'Non_VRES_GWh' to d.d
d.d <- d.d %>%
  mutate(
    VRES_GWh = Photovoltaic_GWh + Wind_GWh,
    Non_VRES_GWh = Hydro_GWh + Nuclear_GWh + Storage_GWh + Thermal_GWh
  )

# View the first few rows to confirm the new columns
head(d.d)

# remove not needed data
remove(energy_production, energy_prices)
```

\newpage
# Introduction
Governments and scientists around the world largely agree on the need for a low-carbon electricity production. A step in this direction is the construction, installation and connection of Renewable Energy Sources (RES) such as Hydropower, Wind and Solar to the electricity grid. These produce little to no direct emissions while supplying electricity and have life cycle carbon costs far lower than fossil fuel **energy sources (@LCElectricity)**. A substrate of RES are so called Variable-RES (VRES), which are electricity sources, whose production cannot easily be increased or decreased by the power plant operator. Wind and Solar both rely on meteorological conditions and if these are not right, nothing is produced. This is contrary to most other energy sources whose production can be increased or decreased according to market needs. although the time it takes to ramp production up or down can still present a challenge. 

The lack of direct control over production with VRES presents a challenge to the adoption of such sources, since they lead to an increased need for short and long term energy storage. Battery Storage, Pumped Hydro and Heat Pumps do store energy, but the current capacity needs to be further increased to adapt to the increased percentage of power production from VRES sources.[^energystorage1]

[^energystorage1]: https://energy.ec.europa.eu/topics/research-and-technology/energy-storage/recommendations-energy-storage_en

The addition of electricity from VRES has the possibility to:

1. Drastically lower electricity prices.[^VRES-L1]
2. Increase price volatility.
3. Rapidly change the quantity of electricity available on the grid in either direction.[^VRES-L2]

[^VRES-L1]: https://www.irena.org/news/pressreleases/2022/Jul/Renewable-Power-Remains-Cost-Competitive-amid-Fossil-Fuel-Crisis
[^VRES-L2]:https://www.next-kraftwerke.de/energie-blog/preisschwankungen-regelenergie

The reason for the first claim is that VRES has practically no marginal costs. No fuel rods, pumping, gas or other notable inputs are required to produce solar and wind energy. This means producers of VRES will bid their energy at almost any price. If they cannot profit - maximize, they will loss - minimize.

The second claim is the case because meteorological events tend to be fairly consistent across an area. When one wind / solar farm is producing, so are the ones around it. This means there is huge downward pressure on prices during periods of favorable VRES production and none at all during unfavorable conditions.

The third claim is particularly relevant for the grid operator, which is responsible for maintaining a stable electricity grid. With the increase of VRES production it can be assumed that the demand for control energy will increase. This increase in demand would lead to higher costs for the TSO and hence for the end consumers.[^next-Kraftwerke]

[^next-Kraftwerke]:https://www.next-kraftwerke.de/energie-blog/preisschwankungen-regelenergie

\newpage
# Context and Framework
## Control Energy
The Transmission System Operator (TSO) has the responsibility to maintain the stability of the electrical grid. A TSO doesn't produce energy itself, but buys control energy from energy producers or some small consumers. This control energy is used in the event of an imbalance between energy production and consumption on the grid.[^Swissgrid1]
The control energy is split up in primary, secondary and tertiary control energy. They differ in activation time (30 seconds, 5 minutes and 15 minutes). Control energy can be tendered separately for positive and negative control energy. Positive control energy corresponds to an increase in generation or reducing consumption, while negative control energy involves decreasing generation or increasing consumption.[^Swissgrid2]
The grid provider pays for the capacity provision (availability of resources that can be mobilized in the required time frame) and for the control energy activated and the costs are passed on to the end consumers.[^elcom2021]

In the Figure \ref{fig:Viz} the event of an energy imbalance on the power grid with the corresponding activation of the control energy is illustrated. It shows the case of the consumption exceeding the production. This could occur for example in the event of an unplanned failure of a power plant. To maintain grid stability (keep the Frequency at the desired 50\ Hz) first the primary positive control energy is activated, which will get replaced by the second control energy, which will get replaced by the tertiary control energy.

\begin{figure}[h]
  \centering
  \includegraphics[width=140mm]{Control-energy-im1.png}
  \caption{Visualization of energy imbalance and control energy activation, adapted from \href{https://www.swissgrid.ch/dam/swissgrid/about-us/newsroom/dossiers/control-energy-market-en.pdf}{Swissgrid}.}
  \label{fig:Viz}
  \centering
\end{figure}

[^Swissgrid1]: https://www.swissgrid.ch/en/home/about-us/company/what-we-do.html
[^Swissgrid2]: https://www.swissgrid.ch/en/home/operation/regulation/grid-stability.html
[^elcom2021]: https://www.elcom.admin.ch/dam/elcom/de/dokumente/2022/berichtregelleistungundregelenergie2021.pdf

\newpage
## Relevance

If the amount of control electricity purchased by Transmission System Operators increases then this means costs will be passed down to consumers. Since electricity is a primary input in the economy, higher prices will be reflected across the vast majority of goods and services. This is an undesirable outcome. It is therefore important for policymakers, stakeholder and the public to understand the drivers of increased prices of control energy. This is particularly important in the context of the SDG 7, which stresses the need for clean energy. Policymakers must understand the impact of increasing the share of VRES on the grid to be aware of potential economic and political backlash of their decisions.

In the Sustainable Development Goal 7 (affordable and clean energy)[^sdg]
[^sdg]: <https://sdgs.un.org/goals>

## Literature Review

The academic literature on VRES's effect on control energy is fairly sparse. Using the search terms "control energy" and "(variable) renewable energy", only one relevant paper was found. @hirth_control_2013 have found that the inclusion of VRES from 2008-2013 decreases procurement cost of control power by 50%, presumably permitting lower prices for end consumers. The broader literature on the effect of VRES on electricity supply is broader.

These areas generally focus on both variability of supply and prices. Amongst them: @pereiradasilva2019 who use EGARCH time series and regression while studying the Iberian power market; @frauendorfer2018 who find that the Swiss are "importing" lower German power prices during peak solar production, as Germany has much more solar energy sources than the Swiss. Finally, the authors @dong2019 find that the Swedish have more stable prices due to the relativley high proportion of non variable fossil and hydropower than the Danes, who are more reliant on VRES in the form of wind and solar. Other studies in the area are more conflicted, such as @rintamäki2017 who compare Germany and Danish prices and wind that the effect of increasing wind production on day ahead prices is not constant. The point is that increasing VRES leads to variability in supply, which presumably means more cost for balancing out an unpredictable supply when the predictions are wrong.

It is the purpose of this study to see whether and if so, to what extent renewable energy sources are related to increasing costs of control energy.

\newpage 
 

# Data Sources
## Data source for control energy
Swissgrid provides a variety of data about electricity in Switzerland, which they make publicly available.[^Swissgrid1] They provide the data in intervals of 15\ minutes. It can be downloaded as a .xls/or/.xlsx file per year. The time period of the data used in the following analysis ranges from the beginning of 2015 until the end of July 2024.
They provide data about the electricity production and consumption for Switzerland and for the individual cantons. Additionally, they also provide the information about control energy (amount and prize), split up in positive and negative as well as secondary and tertiary. There is no data provided about primary control energy.
They state that "The data are reliable from 6 months onwards, until then the partners from the electricity sector who provide Swissgrid with the data can still claim changes."[^Swissgrid1-gen]. This should be kept in mind for the time period of 2024.

[^Swissgrid1-gen]: <https://www.swissgrid.ch/en/home/operation/grid-data/generation.html>

The following table shows an excerpt of the data provided by Swissgrid with an example value.

```{r Table-Swissgrid-Data, include = TRUE, echo=FALSE, message=FALSE, warning=FALSE}

# Read the column names and one sample row from the Excel file
data.example <- read_excel("EnergieUebersichtCH-Example-Data.xlsx",
                           sheet = "Zeitreihen0h15",
                           col_names = FALSE,
                           range = "A1:BM3")

# function to handle splitting of column names
extract_english_part <- function(text) {
  parts <- strsplit(text, "&Linebreak%")[[1]]
  if (length(parts) >= 2) {
    return(parts[2])
  } else {
    return(text)
  }
}

# Extract English column names
v.english_column_names <- sapply(data.example[1, ], extract_english_part)

# Get units and example data row
v.units <- unlist(data.example[2, ])
v.example_data_row <- unlist(data.example[3, ])

# Combine into a new data frame
d.info_df <- data.frame(Column_Name = v.english_column_names,
                        Type = v.units,
                        Example_Value = v.example_data_row)

# Create kable, which will be output
kable(d.info_df, row.names = FALSE,
      caption = "Data provided from Swissgrid",
      col.names = c("column name", "type", "example value"))
```

\newpage
## Data Source for generation share of wind and solar (hourly)
To obtain the percentage of VRES data from the transparency platform from the European Network of Transmission System Operators for Electricity (enstsoe) was used.[^entsoeSource1] After creating an account the data about grid forecast and load ("Actual Total Load [6.1.A]" and "Day-ahead Total Load Forecast [6.1.B]") and the actual generation per production type ("Aggregated Generation per Type [16.1.B&C]") can be obtained. They provide the data in intervals of 1\ hour and the data can be downloaded as a .csv file with a time span of 1 year. The data was obtained for the same time period as the data from Swissgrid and combined for further analysis.

[^entsoeSource1]: https://transparency.entsoe.eu/

```{r Table-Entsoe-Data, include = TRUE, echo=FALSE, message=FALSE, warning=FALSE}
# Extract column names
v.column_names <- c(colnames(df_gen_load_raw))

# Get example data row
v.example_data_row <- unlist(as.vector(df_gen_load_raw[10, ]))

# Combine into a new data frame
d.info_df <- data.frame(Column_Name = v.column_names,
                        Example_Value = v.example_data_row)

# Create kable, which will be output
kable(d.info_df, row.names = FALSE,
      caption = "Data provided from entsoe",
      col.names = c("column name", "example value"))
```

Many columns could be omitted after loading since they contained only "NA" values for every row (for example "Fossil Brown coal/Lignite - Actual Aggregated [MW]" which are not used to produce electricity in Switzerland).

Using this data the percentage of variable renewables (VRES) was calcuted using the following formula
$$
\text{`VRES\_percent`} = \frac{\text{`Solar-Actual Aggregated [MW]`} + \text{`Wind Onshore-Actual Aggregated [MW]`}}{\text{`Actual Total Load [MW] - BZN|CH)`}}
$$
\newline

## Data Source for generation share of wind and solar (daily)
**Will follow**
...

\newpage
# Data exploration
## Cost of control energy

The cost of control energy was aggregated per year to investigate the trend over the years. The Time-Series analysis in the following chapter will further investigate the fluctuations of the cost during the year / days.

The following plot shows the development of the cost Swissgrid spent on control energy over the years. The expenditure stayed relatively stable until the year of 2020, followed by an increase in 2021 and a big increase in the 2022. From 2023 the cost decreased but remained significantly above the average costs of the years before 2021.

```{r, Data exploration_Plot control cost total, include = TRUE, echo = FALSE, cache = TRUE, fig.dim = c(7, 3)}
# Cost aggregated by Year
# Extract the year from the 'Timestamp' column
d.h$year <- year(d.h$Timestamp)

# Identify exact duplicate rows
duplicate_rows <- d.h[duplicated(d.h) | duplicated(d.h, fromLast = TRUE),]
# no dublicate rows

# Reshape the data into long format, selecting all four relevant columns
d.h_long <- d.h %>%
  filter(year != 2024) %>%  # Exclude the year 2024
  pivot_longer(cols = c(cost_pos_sec_EUR, cost_neg_sec_EUR, cost_pos_ter_EUR, cost_neg_ter_EUR), 
               names_to = "cost_type", values_to = "cost_value")

d.h_long$cost_type <- factor(d.h_long$cost_type,
                             levels = c("cost_neg_sec_EUR",
                                        "cost_pos_sec_EUR",
                                        "cost_neg_ter_EUR",
                                        "cost_pos_ter_EUR"))
# Group by 'year' then summarize the total cost
df_yearly_cost <- d.h_long %>%
  group_by(year) %>%
  summarise(total_cost = sum(cost_value, na.rm = TRUE)) %>%
  ungroup()

ggplot(data = df_yearly_cost, aes(x = as.factor(year), y = total_cost / 1e6, group = 1)) + 
  # Add solid lines at every 100 Mio
  geom_hline(yintercept = seq(0, 300, by = 100),
             linetype = "solid", color = "darkgrey") +
  geom_hline(yintercept = 0,
             linetype = "solid", color = "black") +
  geom_line(color = "red", linewidth = 1) +
  geom_point(color = "red", size = 2) +
  ggtitle("Total Cost of Control Energy") +
  xlab("Year") +
  ylab("Total Cost [EUR]") +
  scale_y_continuous(labels = label_number(suffix = " Mio", big.mark = ","),
                     expand = expansion(mult = c(0.1, 0.1))) +
  scale_x_discrete(expand = expansion(mult = c(0.1, 0.1))) +
  theme_minimal() +
  theme(legend.title = element_blank(),  # Hide the legend title
  plot.title = element_text(hjust = 0.5),
  plot.title.position = "plot")
```

In the following plot the cost is split up into the cost for the secondary and tertiary control energy (positive and negative). The plot highlights trends in the costs associated with these control energy types. For the years of 2021 to 2023 a substantial negative cost (profit) is shown for the negative tertiary control energy. The positive tertiary control energy shows as the biggest contributor of the overall costs.

```{r, Data exploration_Plot control cost separated,include = TRUE, echo = FALSE, cache = TRUE, fig.dim = c(7, 3)}
# Group by 'year' and 'cost_type', then summarize the total cost for each
df_yearly_cost <- d.h_long %>%
  group_by(year, cost_type) %>%
  summarise(total_cost = sum(cost_value, na.rm = TRUE), .groups = 'drop') 

# Create a bar plot for the sum of costs per year, with different colors for each 'cost_type'
ggplot(df_yearly_cost, aes(x = as.factor(year), y = total_cost / 1e6, fill = cost_type)) +  # Y-axis in millions
  # Add solid lines at every 100 Mio
  geom_hline(yintercept = seq(-100, 400, by = 100),
             linetype = "solid", color = "darkgrey") +
  geom_hline(yintercept = 0,
             linetype = "solid", color = "black") +
  # Add bar plot
  geom_bar(stat = "identity", position = position_dodge(width = 0.9),
           color = "black") +  # Dodge to separate the bars
  ggtitle("Costs of Secondary and Tertiary Control Energy") +
  xlab("Year") +
  ylab("Total Cost [EUR]") +
  # Format y-axis
  scale_y_continuous(labels = label_number(suffix = " Mio", big.mark = ","),
                     breaks = seq(-100, 400, by = 100),
                     minor_breaks = seq(-100, 400, by = 50),
                     expand = expansion(mult = c(0.05, 0.05))) +
  # Custom colors and labels
  scale_fill_manual(values = c("skyblue2", "lightblue1", "gold", "yellow"), 
                    breaks = c("cost_neg_sec_EUR", "cost_pos_sec_EUR",
                               "cost_neg_ter_EUR", "cost_pos_ter_EUR"),
                    labels = c("neg. Sec.", "pos. Sec.",
                               "neg. Ter.", "pos. Ter.")) +  
  scale_x_discrete(expand = expansion(mult = c(0.1, 0.1))) +  
  theme_minimal() +
  theme(legend.title = element_blank(),  # Hide the legend title
  plot.title = element_text(hjust = 0.5),
  plot.title.position = "plot")

```


## Overview Variable Renewable Energy Sources 
The following graphs show the power generation of solar and wind power in Switzerland using the available hourly data from the entsoe platform ([Data Source for generation share of wind and solar (hourly)]).
The first graph prints the values "as-is" which basically creates a plot where the peak values are displayed. The second plot uses a moving-average (`SMA`) over 24 hours, which displays the average production during a day.
The graphs show a clear seasonality for the solar power (increased production during the summer). The wind power makes up a small fraction of the power production compared to solar power, especially considering the graphs with the peak hours.

```{r, Data exploration_Plot wind solar hourly,include = TRUE, echo = FALSE, cache = TRUE, fig.dim = c(7, 3)}
ggplot(d.h) + 
  # Solar generation in the background
  geom_line(aes(x = Timestamp, y = CH_solar_generation_actual_MW, color = "Solar"), linewidth = 1) + 
  # Wind generation in the foreground
  geom_line(aes(x = Timestamp, y = CH_wind_onshore_generation_actual_MW, color = "Wind"), linewidth = 1) + 
  ggtitle("Wind and Solar power generation (peak hours)") +
  xlab("Date") +
  ylab("Generation (MW)") +
  scale_color_manual(values = c("Wind" = "blue", "Solar" = "orange")) + 
  theme_minimal() +
  geom_hline(yintercept = 0,
             linetype = "solid", color = "black") +
  labs(color = "Generation Type") + 
  theme(plot.title = element_text(hjust = 0.5), plot.title.position = "plot")
```


```{r, Data exploration_Plot wind solar hourly MA,include = TRUE, echo = FALSE, cache = TRUE, fig.dim = c(7, 3)}
# Daily Moving Average
# Plot the filtered data with wind in the foreground and solar in the background
ggplot(d.h) + 
  # Solar generation in the background
  geom_ma(ma_fun= SMA, n = 24, aes(x = Timestamp, y = CH_solar_generation_actual_MW, color = "Solar"), linewidth = 1) +

# Wind generation in the foreground
  geom_ma(ma_fun= SMA, n = 24, aes(x = Timestamp, y = CH_wind_onshore_generation_actual_MW, color = "Wind"), linewidth = 1) + 
  ggtitle("Wind and Solar power generation (24h moving average)") +
  xlab("Time") +
  ylab("Generation (MW)") +
  scale_color_manual(values = c("Wind" = "blue", "Solar" = "orange")) + 
  theme_minimal() +
  geom_hline(yintercept = 0,
             linetype = "solid", color = "black") +
  labs(color = "Generation Type") + 
  theme(plot.title = element_text(hjust = 0.5), plot.title.position = "plot")
```

With the solar production there seems to be a big change from end of 2019 to beginning of 2020. Up until that moment the production remains low and quite constant over the years. After that the production increases by a factor of approximately 5. It is assumed that the reporting of the data was changed with the start of the year 2020, for example by newly taking into account the production of solar power at individual households. But no source could be found which explained this described change in the production.

Using the daily data from a different data source ([Data Source for generation share of wind and solar (daily)]) there is no jump in production at the start of 2020. This can be seen in the following graph showing development of the daily energy production (in GWh) using this data. The values after the year 2020 are comparable using the different data sets (can be compared by multiplying the 24h moving average by 24 hours).

```{r, Data exploration_Plot wind solar daily,include = TRUE, echo = FALSE, cache = TRUE, fig.dim = c(7, 3)}
# Plot the Daily Generation with wind in the foreground and solar in the background
ggplot(d.d) + 
  # Solar generation in the background
  geom_line(aes(x = Date, y = Photovoltaic_GWh,
                color = "Solar"), linewidth = 1) + 
  # Wind generation in the foreground
  geom_line(aes(x = Date, y = Wind_GWh, color = "Wind"), linewidth = 1) + 
  ggtitle("Wind and Solar power generation (daily data)") +
  xlab("Date") +
  ylab("Generation (GWh)") +
  scale_color_manual(values = c("Wind" = "blue", "Solar" = "orange")) + 
  theme_minimal() +
  geom_hline(yintercept = 0,
             linetype = "solid", color = "black") +
  labs(color = "Generation Type") + 
  theme(plot.title = element_text(hjust = 0.5), plot.title.position = "plot")
```

The graph below displays VRES\_percent (Variable Renewable Energy production in Switzerland as a percentage of energy consumed) over time. A clearly cyclical  pattern can be identified, indicating the presence of seasonality, which is expected due to the seasonal nature of solar energy production. The effect at the beginning of 2020 is reflected in this graphs as well since the calculation of the percentage of VRES is done using the hourly data of the power generation.

The maximum value has been pushed up noticeably every year since 2020 and almost reached 60%. This high value represents a peak hour. When looking at the moving average, where each dot represents the average contribution over a 24 hour period, this share is lowered significantly, still reaching a contribution of 20% to the daily energy consumed in the last recorded summer of 2024. 

```{r, Data exploration_VRES peak,include = TRUE, echo = FALSE, cache = TRUE, fig.dim = c(7, 3)}
# VRES_percent Range
min_VRES <- min(d.h$VRES_percent, na.rm = TRUE)
max_VRES <- max(d.h$VRES_percent, na.rm = TRUE)

# Plot the filtered data
ggplot(d.h, aes(x = Timestamp, y = VRES_percent * 100)) + 
  geom_line(color = "blue", linetype = "solid", linewidth = 0.5) + 
  ggtitle("VRES percentage (peak hour)") +
  xlab("Time") +
  ylab("VRES percentage") +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) + 
  theme_minimal() +
  geom_hline(yintercept = 0,
             linetype = "solid", color = "black") +
  theme(plot.title = element_text(hjust = 0.5), plot.title.position = "plot")
```


```{r, Data exploration_VRES MA,include = TRUE, echo = FALSE, cache = TRUE, fig.dim = c(7, 3)}
# Moving Average
ggplot(d.h)+ 
  geom_ma(ma_fun= SMA, n = 24, aes(x = Timestamp, y = VRES_percent* 100),
          linetype = "solid", linewidth = 0.5) + 
  ggtitle("VRES percentage (24h moving average)") +
  xlab("Time") +
  ylab("VRES percentage") +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) + 
  theme_minimal() +
  geom_hline(yintercept = 0,
             linetype = "solid", color = "black") +
  theme(plot.title = element_text(hjust = 0.5), plot.title.position = "plot")
```



# Control Costs (Time Series)
## Time Series of Hourly Data
### Visualization of Control Costs

```{r, vres ts prep1, include = FALSE, warning = F}
# Convert the Timestamp column to a Date-Time object
d.h$Timestamp <- as.POSIXct(d.h$Timestamp, format="%Y-%m-%d %H:%M:%S")

# Replace NAs in 'VRES_percent' with zero
d.h$VRES_percent[is.na(d.h$VRES_percent)] <- 0

# Convert VRES_percent into a time series object
VRES_ts <- ts(d.h$VRES_percent, start=c(2015, 1), frequency=24*365.25)  # Assuming hourly data
```

The first plot illustrates the cost of control energy over time, measured in EUR per MWh, from 2015 through 2024. The x-axis represents the time period, while the y-axis reflects the control energy costs in EUR. The graph reveals an overall increasing trend in control costs as time progresses, with periods of volatility that become more pronounced starting in late 2020. Although the costs were relatively stable from 2015 until 2020, with only minor spikes, a noticeable rise in both the frequency and magnitude of cost fluctuations is observed from 2021 onwards. This suggests that control energy costs became more volatile, with significant spikes emerging around 2022 and peaking in late 2023 and early 2024.

```{r, plot ts of control cost, echo = FALSE, warning = F, message = F}

# Create the plot for VRES_percent with a linear trend line
ggplot(d.h, aes(x = as.Date(Timestamp), y = total_cost_EUR)) +
  geom_line(color = "darkblue") +                     
  geom_smooth(method = "lm", color = "black", se = FALSE) +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
  labs(title = "Cost of Control Energy Over Time",
       x = NULL, 
       y = "Cost in EUR per MWh")
```

One notable aspect of the data is the presence of multiple sharp peaks, indicating sudden surges in costs, which likely correspond to times of increased demand for control energy or variability in renewable energy generation. These peaks, reaching prices beyond EUR 7.5 million per MWh, imply high operational costs during these periods. Additionally, there are moments where the costs drop to zero or even become negative. Negative costs could imply that Swissgrid occasionally earns money, likely through balancing mechanisms when energy supply exceeds demand, thus allowing the sale of excess energy to other countries.

### 3.2. Decomposition of Control Costs

```{r, costs ts prep, include = FALSE, warning = F}
# Convert the Timestamp column to a Date-Time object
d.h$Timestamp <- as.POSIXct(d.h$Timestamp, format="%Y-%m-%d %H:%M:%S")

# Replace NAs in 'total_cost_EUR' with zero
d.h$total_cost_EUR[is.na(d.h$total_cost_EUR)] <- 0

# Convert total_cost_EUR into a time series object
total_cost_EUR_ts <- ts(d.h$total_cost_EUR, start = c(2015, 1), end = c(2024, 8), frequency=24*365.25)
```

```{r, costs additive decomposition, echo = FALSE, warning = F}

# Decompose the time series
cost_decomposed <- decompose(total_cost_EUR_ts)
plot(cost_decomposed)
```

The  decomposition into trend, seasonal, and remainder components provides insights into the underlying structure of the control cost data. The trend component reveals an upward trajectory starting in late 2020, peaking in mid-2023, and slightly declining towards the end of the observation period. This indicates that control costs were steadily increasing over time. The seasonal component exhibits recurring peaks and troughs, which suggests the presence of consistent, cyclical patterns in the control costs. These seasonal fluctuations could be linked to predictable changes in energy demand or production patterns, such as variations in solar and wind power generation.
The remainder (random) component still displays a substantial amount of unexplained variance, especially towards the later years of the time series. There is notable volatility in this component, which could be attributed to external factors or events not captured by the trend or seasonality, such as sudden shifts in energy market conditions or unexpected changes in demand. Given this, while the decomposition successfully highlights the importance of the trend and seasonal components, the remainder indicates a significant level of residual variability that could require further exploration. We believe that exogenous factors, like the war in the Ukraine, have contributed to increased noise in the remainder, starting in 2022. To control for these factors, in the next section, we will consider the time period up to end of 2021.

### 3.3. Stationarity of Control Costs

For the time series analysis of control costs, achieving stationarity is important to ensure valid modeling results. Initially, the original time series showed signs of non-stationarity, with an increasing trend and rising variance over time. This non-constant behavior is particularly evident due to the sharp cost increases in certain periods. Given the multiplicative nature of the data, a log transformation was first applied to stabilize the variance, addressing the large fluctuations in the original series.

```{r, differencing of day-ahead 1, echo = FALSE, warning = FALSE}
# Reflect period until end of 2021
total_cost_EUR_ts <- ts(d.h$total_cost_EUR, start = c(2015, 1), end = c(2021, 12), frequency=24*365.25)

# Apply log transformation (add a small constant to avoid log(0) issues)
costs_log <- log(total_cost_EUR_ts + 1e-6)

# Apply first-order differencing to remove the trend
costs_log_diff <- diff(costs_log, differences = 1)
sum(is.na(costs_log_diff))
costs_log_diff <- na.approx(costs_log_diff)
sum(is.na(costs_log_diff))

# Plot the differenced series
plot(costs_log_diff, main="Differenced Total Costs Time Series")

```

Following the log transformation, first-order differencing was applied to remove the trend from the time series. While this step successfully eliminated much of the trend, the resulting series still showed signs of variation over time, indicating the presence of seasonality. The plot of the differenced series showed reduced but not entirely constant variance, suggesting that further adjustments were needed.

```{r, differencing of day-ahead 2, echo = FALSE, warning = FALSE}
# Apply seasonal differencing (assuming yearly seasonality with a frequency of 365)
costs_log_diff_seasonal <- diff(costs_log_diff, lag = 365)

# Plot the seasonally differenced series
plot(costs_log_diff_seasonal, main="Seasonally Differenced Total Costs Time Series")

```

To address the cyclical nature of the data, seasonal differencing with a lag of 365 (corresponding to annual seasonality) was applied. This step accounted for recurring yearly patterns, resulting in a more stationary time series. The second plot, "Seasonally Differenced Total Costs Time Series," demonstrates that the variance has been more effectively stabilized compared to the non-seasonally differenced series.

```{r, costs adf, echo = FALSE, warning = FALSE}

# Perform Augmented Dickey-Fuller test
adf.test(costs_log_diff_seasonal)
```

Finally, an Augmented Dickey-Fuller (ADF) test was performed on the seasonally differenced series, yielding a p-value smaller than 0.01. This result indicates that the null hypothesis of non-stationarity can be rejected with high confidence, confirming that the seasonally differenced series is stationary.The combined use of log transformation, first-order differencing, and seasonal differencing ensures that the time series is stationary. This stationarity is crucial for the validity of subsequent modeling, particularly when analyzing the control costs up to the end of 2021 to avoid confounding effects from external shocks like the war in Ukraine.

### 3.4. Visualization of Variable Renewable Energy Sources (VRES) Control Energy

```{r, plot ts of vres percent, echo = FALSE, warning = F}

# Create the plot for VRES_percent with a linear trend line
ggplot(d.h, aes(x = as.Date(Timestamp), y = VRES_percent)) +
  geom_line(color = "darkgreen") +                     # Line plot of VRES_percent
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Add linear trend line
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
  labs(title = "VRES Percentage Over Time",
       x = NULL, 
       y = "VRES Percent")
```

The time series plot of Variable Renewable Energy Sources (VRES) percentage over time illustrates the proportion of VRES in the overall energy mix from 2015 through 2024. The x-axis represents time, while the y-axis shows the percentage of VRES, which fluctuates seasonally throughout the observed period. The data displays a clear seasonal pattern, with recurring peaks and troughs each year, likely tied to natural variations in solar and wind power generation. There is also a discernible upward trend, indicating a steady increase in the share of VRES over time, especially from 2020 onwards. This growth reflects the increasing penetration of renewable energy into the grid. The spikes and seasonal fluctuations suggest periods of high renewable generation, with sharp increases likely corresponding to periods of favorable weather conditions for solar and wind energy production. This trend will be further examined through decomposition to better understand the underlying components of the series.

### 3.5. Decomposition of VRES Control Energy

```{r, vres ts prep2, include = FALSE, warning = F}
# Convert the Timestamp column to a Date-Time object
d.h$Timestamp <- as.POSIXct(d.h$Timestamp, format="%Y-%m-%d %H:%M:%S")

# Replace NAs in 'VRES_percent' with zero
d.h$VRES_percent[is.na(d.h$VRES_percent)] <- 0

# Convert VRES_percent into a time series object
VRES_ts <- ts(d.h$VRES_percent, start = c(2015, 1), end = c(2024, 8), frequency=24*365.25)
```

The below plot shows the decomposition of the VRES time series. The observed panel shows seasonal peaks occurring annually, reflecting the cyclical nature of renewable energy generation. The trend component shows a relatively flat trajectory until 2019, after which there is a noticeable upward shift, indicating a substantial increase in VRES share from 2020 onwards. While this upward trend aligns with the growing share of renewable energy sources in the grid, especially solar and wind energy, it is unclear to us at this point whether this sharp increase is due to the heavy ramp-up of VRES or other factors contributing to the surge, such as different calculation methods.

```{r, vres additive decomposition, echo = FALSE, warning = FALSE}
# Decompose the time series
VRES_decomposed <- decompose(VRES_ts)
plot(VRES_decomposed)
```

The seasonal component exhibits a clear and consistent annual pattern, with large, predictable peaks occurring each year. These peaks are indicative of the regular variation in renewable energy production, likely driven by seasonal factors such as weather patterns, which affect solar radiation and wind speeds. The random component shows some variations, indicating that there may be structures int he data that is not captured by the trend and seasonal components. In fact, the random component does show increased variability in the later years, which may correspond to irregularities or external shocks affecting renewable generation.

Given the observed trend and seasonality, the analysis of VRES' impact on control costs will focus on the data up to the end of 2021, thereby excluding the post-2021 period where external factors (such as the war in Ukraine) may have contributed to increased volatility.

### 3.6. Stationarity of VRES Control Energy

We are now turning to the stationarity analysis, which will prepare the data for use in a vector autoregression (VAR) model and Granger cusality test aimed at forecasting control costs using VRES as a key predictor.

```{r, vres adf1, echo = FALSE, warning = F}

# Perform Augmented Dickey-Fuller test
adf.test(VRES_ts)
```

The Augmented Dickey-Fuller test of the VRES time series has a p-value of 0.01 although the decomposition clearly shows a trend, seasonality and also a change in randomness. We suspect a decomposition of a multiplicative time series might help. A multiplicative decomposition assumes that the components (trend, seasonality, and noise) interact in a multiplicative manner. This is often suitable when the variability of the time series increases as the level of the series increases, which might be indicated by the trend and seasonal patterns with the overall level.

Applying a log transformation to the data can stabilize the variance, which often makes the series more appropriate to decomposition or modeling. The log-transformation essentially converts a multiplicative relationship into an additive one.

```{r, vres multiplicative decomposition, echo = FALSE, warning = F}

# Apply log transformation (add a small constant to avoid log(0) issues)
VRES_log <- log(VRES_ts + 1e-6)

# Decompose the log-transformed time series
VRES_log_decomposed <- decompose(VRES_log)
plot(VRES_log_decomposed)

```

The decomposition of the log-transformed series still reveals a clear upward trend and significant seasonality, indicating that the series is not yet stationary despite an initial low p-value from the Augmented Dickey-Fuller test. This suggests that, while the variance was stabilized, the time series still contains structural components (trend and seasonal patterns) that need to be addressed. Therefore, the next steps involve applying first-order differencing to remove the underlying trend and seasonal differencing to eliminate cyclical variations. These transformations will help ensure the series is stationary.

```{r, vres differencing, echo = FALSE, warning = F}
# Apply first-order differencing to the log-transformed series
VRES_log_diff <- diff(VRES_log)

# Plot the differenced series
# plot(VRES_log_diff, main="Differenced Log-Transformed VRES Time Series")

# Apply seasonal differencing
VRES_log_seasonal_diff <- diff(VRES_log_diff, lag = 365)
sum(is.na(VRES_log_seasonal_diff))

# Plot the seasonally differenced log-transformed series
plot(VRES_log_seasonal_diff, main="Seasonally Differenced Log-Transformed VRES Time Series")

VRES_log_seasonal_diff_decomp <- decompose(VRES_log_seasonal_diff)
plot(VRES_log_seasonal_diff_decomp)
```

The resulting seasonally differenced, log-transformed series exhibits fluctuations around a constant mean with stable variance, as shown in the "Seasonally Differenced Log-Transformed VRES Time Series" plot. The decomposition of the differenced series confirms the absence of any significant remaining trend or seasonal patterns, with most variation captured in the random component. To verify stationarity, an Augmented Dickey-Fuller test was conducted, yielding a test statistic of -65.948 and a p-value smaller than 0.01. This result also rejects the null hypothesis of non-stationarity, indicating that the series is now stationary. The series is now ready for further analysis, such as Vector Autoregression (VAR), to assess its relationship with control costs.

```{r, stationarity vres, echo = FALSE, warning = TRUE}

adf.test(VRES_log_seasonal_diff)
```

```{r, vres sarima, include = FALSE, echo = FALSE, warning = F}

# Fit a SARIMA model using auto.arima
#sarima_model_h <- auto.arima(VRES_ts, seasonal = TRUE)

# Summary of the SARIMA model
#summary(sarima_model_h)

# Check residuals of the SARIMA model
#checkresiduals(sarima_model_h)

```

```{r, vres forecasting, include = FALSE, echo = FALSE, warning = F}
# Forecast the next 365 periods (adjust as needed)
#sarima_forecast_h <- forecast(sarima_model_h, h = 365)

# Plot the forecast
#plot(sarima_forecast_h)

```

### 3.7. Vector Autoregression (VAR) of VRES Impact on Total Control Costs

The next step in the analysis is to apply a Vector Autoregression (VAR) model to assess the linear interdependencies between time series. In this case, the VAR model will be used to analyze the dynamic relationship between VRES and control costs. By incorporating both the stationary VRES and control cost time series, the VAR model will help identify how changes in VRES affect control costs over time while accounting for the lagged effects of each variable on the other. We hope to provide insights into the impact of renewable energy integration on the grid's operational costs. We start by determining the optimal lag length.

```{r, align length time series, echo = FALSE, warning = FALSE}
# Reflect period until end of 2021
VRES_ts <- ts(d.h$VRES_percent, start = c(2015, 1), end = c(2021, 12), frequency=24*365.25)

# Apply log transformation (add a small constant to avoid log(0) issues)
VRES_log <- log(VRES_ts + 1e-6)

# Apply first-order differencing to the log-transformed series
VRES_log_diff <- diff(VRES_log)

# Apply seasonal differencing
VRES_log_seasonal_diff <- diff(VRES_log_diff, lag = 365)

# Check length
length(costs_log_diff_seasonal)
length(VRES_log_seasonal_diff)
```

```{r, lag length var, echo = TRUE, warning = F}
# Check for NAs
sum(is.na(costs_log_diff_seasonal))  # Check for NAs in costs_log_diff
sum(is.na(VRES_log_seasonal_diff))  # Check for NAs in VRES_log_seasonal_diff

# Determine lag length
VARselect(cbind(costs_log_diff_seasonal, VRES_log_seasonal_diff), lag.max = 10, type = "const")
```

The lag length selection process indicates that the optimal lag length is 10 according to all criteria (AIC, HQ, SC, and FPE). This suggests that incorporating 10 lags will provide the best model fit while capturing the dynamics between the differenced control costs and VRES time series. With this optimal lag length determined, the next step is to estimate the VAR model and analyze the interactions between the variables.

```{r, var model, echo = TRUE, warning = FALSE, cache = TRUE}
var_model <- VAR(cbind(costs_log_diff_seasonal, VRES_log_seasonal_diff), 
                 p = 10, type = "const")
summary(var_model)

```

The results of the VAR model estimation provide valuable insights into the dynamic relationship between control costs and VRES. For the equation predicting control costs (costs_log_diff_seasonal), several lags of the VRES variable are significant. Specifically, VRES at lags 1, 4, 6, 7, and 10 have significant coefficients, indicating that changes in VRES have both immediate and delayed effects on control costs. For instance, the negative coefficient for the first lag of VRES (-0.0139, p = 0.004) suggests that an increase in VRES has a small but statistically significant immediate downward impact on control costs. Conversely, the positive coefficients at lags 4, 5, and 6 indicate that VRES fluctuations at earlier periods can lead to a subsequent rise in control costs. Overall, the F-statistic for this equation (978.4, p < 2.2e-16) and adjusted R-squared of 0.2723 suggest that the model explains a moderate portion of the variability in control costs, with a strong relationship captured over the 10 lags.

For the equation predicting VRES (VRES_log_seasonal_diff), most of the significant effects are driven by the variable's own lags, rather than control costs. VRES is highly influenced by its own history, with significant coefficients at many lags (1, 2, 3, 4, 5, and others), demonstrating the strong autocorrelation and persistence in renewable energy generation patterns. Control costs do not appear to significantly influence VRES, with only a few lags (such as lag 9 and 10) showing significant coefficients. The adjusted R-squared of 0.05423 for the VRES equation suggests that other factors, not captured in this model, likely explain the majority of the variation in VRES. The overall low correlation (0.001467) between the residuals of the two equations further confirms that VRES and control costs have a relatively low degree of direct correlation in the residual unexplained portions of the time series. Overall, the results imply that while VRES has a measurable impact on control costs, control costs have little reciprocal effect on VRES generation.

### 3.8. Granger Causality Test of VRES Impact on Total Control Costs

To further investigate the causal relationship between VRES  and control costs, a Granger causality test will be conducted. This test is designed to determine whether past values of one time series can help predict future values of another. Specifically, it will assess whether changes in VRES "Granger-cause" variations in control costs. By applying this test, we can determine if VRES has a predictive influence on control costs beyond their own historical patterns, solidifying the insights gained from the VAR model. This will provide a more in-depth understanding of the interactions between renewable energy penetration and grid operation costs.

```{r, granger, echo = TRUE, warning = FALSE}
# Perform Granger causality
causality(var_model, cause = "VRES_log_seasonal_diff")

```

The results of the Granger causality test provide strong evidence that VRES Granger-cause changes in control costs. The F-test statistic of 4.8896, with a very low p-value, allows us to confidently reject the null hypothesis that VRES does not Granger-cause control costs. This means that past values of VRES have predictive power over future variations in control costs, suggesting that fluctuations in renewable energy penetration directly influence the costs of maintaining grid stability. This reinforces the findings from the VAR model, where certain lags of VRES were found to have significant effects on control costs. However, the test for instantaneous causality between VRES and control costs yields a Chi-squared statistic of 0.11246 and a p-value of 0.7374, indicating no significant evidence of instantaneous causality between the two variables. In summary, VRES has a predictive, lagged impact on control costs, but the relationship is not instantaneous, highlighting the importance of considering the delayed effects of renewable energy integration on grid operation expenses.

# 4. Time Series of Daily Benchmark Data
## Daily VRES and non-VRES Production

This chapter deals with the benchmark data of daily VRES production and day-ahead prices.

### 4.1. Visualization of Daily VRES and non-VRES Production

```{r, sun and wind visualization, echo = FALSE, warning = F}

ggplot(d.d %>%
         select(Date, Photovoltaic_GWh, Wind_GWh) %>%
         pivot_longer(cols = c(Photovoltaic_GWh, Wind_GWh), 
                      names_to = "Source", 
                      values_to = "GWh"), 
       aes(x = as.Date(Date), y = GWh, color = Source)) +
  geom_line(size = 1) +
  labs(title = "Time Series of Photovoltaic and Wind Energy Production",
       x = NULL, y = "Energy Production (GWh)") +
  scale_color_manual(values = c("Photovoltaic_GWh" = "orange", "Wind_GWh" = "darkgrey")) +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")
```

The first graph illustrates the evolution of photovoltaic and wind energy production over time. Photovoltaic production (in orange) exhibits a clear seasonal pattern, with higher output during the summer months and lower production in winter, reflecting the natural variation in solar energy availability. In contrast, Wind production (in grey) remains consistently low throughout the year with some fluctuations but no clear trend, indicating that wind energy may play a relatively small role in the overall energy production mix compared to photovoltaic energy.

```{r, vres visualization, echo = FALSE, warning = F}

ggplot(d.d %>%
         select(Date, VRES_GWh, Non_VRES_GWh) %>%
         pivot_longer(cols = c(VRES_GWh, Non_VRES_GWh), 
                      names_to = "Source", 
                      values_to = "GWh"), 
       aes(x = as.Date(Date), y = GWh, color = Source)) +
  geom_line(size = 1) +
  labs(title = "Time Series of VRES and Non-VRES Production",
       x = NULL, y = "Energy Production (GWh)") +
  scale_color_manual(values = c("VRES_GWh" = "darkgreen", "Non_VRES_GWh" = "black")) +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")
```

The second graph compares VRES (Variable Renewable Energy Sources, including Photovoltaic and Wind) with Non-VRES (comprising Hydro, Nuclear, Storage, and Thermal energy). The Non-VRES sources (in black) dominate total energy production and display significant variability over time, driven by factors such as fluctuating demand and adjustments in non-renewable energy generation. VRES production (in green), while much lower in magnitude, shows a clear seasonal trend, largely driven by photovoltaic energy, with peaks in the summer months.

### 4.2. Decomposition of Daily VRES Production

```{r, decomposition, echo = FALSE, warning = F}
# Create a time series object for VRES production (Photovoltaic + Wind)
vres_ts_d <- ts(d.d$VRES_GWh, start = c(2017, 1), frequency = 365)

# Decompose the VRES time series
vres_decomp_d <- decompose(vres_ts_d)
plot(vres_decomp_d, xlab = NULL)

# Check the first few values of each component
head(vres_decomp_d$trend)
head(vres_decomp_d$seasonal)
head(vres_decomp_d$random)
```

The decomposition reveals a clear linear trend and strong seasonal patterns, with some variability in both the seasonal component and residuals. While the seasonal noise is expected due to the nature of renewable energy sources like photovoltaic and wind, it does not obscure the overall pattern. The fluctuations in the residuals suggest potential volatility of variance, but this can be addressed by examining the residuals further after modeling.

### 4.3. Stationarity of Daily VRES Production

As in previous steps, we apply a log-transformation as well as regular differencing to remove the linear trend and since there is seasonality, we also apply seasonal differencing.

```{r, differencing vres, echo = FALSE, warning = F}
# Apply log transformation (add a small constant to avoid log(0) issues)
vres_log_d <- log(vres_ts_d + 1e-6)

# Apply first-order differencing to the log-transformed series
vres_log_diff_d <- diff(vres_log_d)

# Apply seasonal differencing
vres_log_seasonal_diff_d <- diff(vres_log_diff_d, lag = 365)
sum(is.na(vres_log_seasonal_diff_d))

plot(vres_log_seasonal_diff_d, main="Log-Transformed and Seasonally Differenced VRES Time Series", 
     ylab = "Differenced GWh", 
     xlab = NULL)

```

```{r, decomposition vres, echo = FALSE, warning = F}
# Decomposition of fully differenced time series 
vres_log_seasonal_diff_d_decomp <- decompose(vres_log_seasonal_diff_d)
plot(vres_log_seasonal_diff_d_decomp)
```

```{r, vres stationarity, echo = TRUE, warning = TRUE}
# Perform ADF test to check stationarity
adf.test(vres_log_seasonal_diff_d)
```

The first plot presents the fully differenced series, which now fluctuates around a constant mean with reduced variance, indicating a more stable time series. The decomposition in the second plot confirms that both trend and seasonal components have been largely removed, leaving the random component as the main driver of variability. The results of the Augmented Dickey-Fuller (ADF) test confirm the stationarity of the differenced time series, with a Dickey-Fuller test statistic of -22.628 and a p-value smaller than 0.01, allowing us to reject the null hypothesis of non-stationarity. With the series now stationary, it is ready for further analysis

### 4.4. Forecast of Daily VRES Production

After confirming the stationarity of the VRES daily time series, we proceeded with analyzing its Autocorrelation Function (ACF) and Partial Autocorrelation Function (PACF). The ACF plot (first image) reveals that after the first lag, the autocorrelations drop off quickly and remain within the confidence bounds, suggesting limited autocorrelation beyond the immediate past values. This indicates that the series does not exhibit strong long-term memory, and most of the autocorrelation is explained by the first few lags.

```{r, daily vres acf pacf, echo = FALSE, warning = F}
# ACF and PACF for the log-transformed differenced series
acf(vres_log_seasonal_diff_d)
pacf(vres_log_seasonal_diff_d)
```

The PACF plot (second plot) shows a more gradual decline with significant negative partial autocorrelations up to lags beyond lag 10. This behavior suggests that a few past observations have a direct influence on the current value. We will now proceed with the SARIMA forecast.

```{r, daily vres_sarima model, echo = FALSE, warning = F, cache = T}

# Fit a SARIMA model with auto.arima to handle seasonality
sarima_model <- auto.arima(vres_ts_d, seasonal = TRUE)

# Summary of the fitted model
summary(sarima_model)

```

The fitted SARIMA(3,1,1)(0,1,0)[365] model effectively captures both short-term and seasonal patterns in the VRES time series. The significant autoregressive terms (especially AR1 at 0.3929) and the large negative moving average term (MA1 at -0.9766) indicate that recent past values and residuals from previous periods strongly influence future VRES values. The model shows a good fit with a sigma² of 7.477 and low residual autocorrelation (ACF1 = 0.0009), suggesting that most of the autocorrelation has been captured.

The residual analysis (plot below) further supports the model's adequacy: the residuals appear randomly distributed around zero, the ACF plot of residuals shows significant autocorrelations at the year mark, and the residuals’ histogram closely follows a normal distribution. Error metrics, including an RMSE of 2.547 and MAPE of 27.52%, indicate moderate forecasting accuracy, while the AIC (11819.13) and BIC (11848.12) confirm the model's parsimony. Overall, this SARIMA model provides a good balance between capturing seasonal trends and ensuring predictive accuracy.

```{r, sarima residuals, echo = FALSE, warning = F}

# Check residuals of the SARIMA model
checkresiduals(sarima_model)

```

The SARIMA forecast visualization below provides an outlook for VRES energy production over the next two years, continuing from the historical data. The forecast shows a continuation of the established seasonal patterns, with recurring peaks and troughs that align with the cyclical nature of renewable energy production. The forecasted values exhibit an expected upward trend in energy production, consistent with recent years, indicating a gradual increase in VRES generation. The shaded area around the forecast line represents the prediction intervals, with wider bands toward the end of the forecast horizon, reflecting increased uncertainty as we look further into the future.

```{r, sarima plot, echo = FALSE, warning = F, cache = T}

# Forecast the next years
sarima_forecast <- forecast(sarima_model, h = 730)

# Plot the forecast
#plot(sarima_forecast, main="SARIMA Forecast for VRES Time Series")

# Visualize the SARIMA forecast with confidence intervals
autoplot(sarima_forecast) +
  ggtitle("SARIMA Forecast for VRES Time Series") +
  xlab("Date") +
  ylab("Energy Production (GWh)")
```


## Daily Data of Day-Ahead Prices of Baseload
### 4.5. Visualization of Day-Ahead Prices

We now would like to turn our attention to the baseload energy prices in EUR/MWh over time. From 2017 through most of 2021, prices remained relatively stable, fluctuating within a narrow range with occasional spikes. However, from the end of 2021 through 2023, there is a sharp and sustained increase in energy prices, with peaks exceeding 600 EUR/MWh and increased volatility. This surge is likely driven by exogenous factors, including the geopolitical tensions and market disruptions we previously identified. After mid-2023, prices gradually return to lower levels but still exhibit heightened volatility compared to pre-2021 levels. This period of extreme price fluctuations highlights the sensitivity of energy markets to external shocks.

```{r, day-ahead baseload_plot of day-ahead, echo = FALSE, warning = F}

# Create a line plot of Baseload_EUR_MWh over time
ggplot(d.d, aes(x = as.Date(Date), y = Baseload_EUR_MWh)) +
  geom_line(color = "darkblue", size = 0.5) +
  labs(title = "Baseload Energy Prices Over Time",
       x = NULL, 
       y = "Baseload (EUR/MWh)") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")

```

### 4.6. Decomposition of Day-Ahead Prices

The observed panel of the below decomposition of the baseload energy prices shows the original data with significant spikes in prices from late 2021 through 2023, assumed to correspond to external market shocks. The trend component highlights a clear upward shift during this period, reflecting the sustained increase in energy prices caused by exogenous factors, followed by a gradual decline post-2023. The seasonal component exhibits recurring cyclical patterns, suggesting that energy prices also follow a predictable annual cycle, likely tied to demand patterns or seasonal energy production fluctuations. Lastly, the random component captures residual volatility, with pronounced variability during the price spikes in 2022 and 2023, indicating the presence of irregular shocks not explained by the trend or seasonality. 

```{r, day-ahead baseload_decomposition,  echo = FALSE, warning = F}
# Convert the Baseload_EUR_MWh column to a time series object
# Assuming daily data, we set frequency = 365 for yearly seasonality
baseload_ts <- ts(d.d$Baseload_EUR_MWh, start = c(2017, 1), frequency = 365)

# Decompose the time series into trend, seasonal, and random components
decomp_baseload <- decompose(baseload_ts)

# Plot the decomposition
plot(decomp_baseload)

```

### 4.7. Stationarity of Day-Ahead Prices

```{r, day-ahead baseload_differencing 1, echo = FALSE, warning = F}
# # Apply first-order differencing to remove the trend
# diff_baseload_ts <- diff(baseload_ts, differences = 1)
# 
# # Plot the differenced series
# plot(diff_baseload_ts, main="Differenced Baseload Time Series")
# 
# # Apply seasonal differencing (assuming yearly seasonality with a frequency of 365)
# seasonal_diff_baseload_ts <- diff(diff_baseload_ts, lag = 365)
# 
# # Plot the seasonally differenced series
# plot(seasonal_diff_baseload_ts, main="Seasonally Differenced Baseload Time Series")

```

To stabilize the variance and remove the trend and seasonality in the time series, we apply a log-transformation, followed by first-order differencing to eliminate the linear trend and seasonal differencing to account for cyclical patterns in the data.

```{r, day-ahead baseload_differencing 2, echo = FALSE, warning = F}
# Apply log transformation (add a small constant to avoid log(0) issues)
baseload_log_d <- log(baseload_ts + 1e-6)

# Apply first-order differencing to the log-transformed series
baseload_log_diff_d <- diff(baseload_log_d)

# Apply seasonal differencing
baseload_log_seasonal_diff_d <- diff(baseload_log_diff_d, lag = 365)
sum(is.na(baseload_log_seasonal_diff_d))

plot(baseload_log_seasonal_diff_d, 
     main="Log-Transformed and Seasonally Differenced Baseload Time Series", 
     ylab = "Differenced EUR", 
     xlab = NULL)

```

After the initial transformations, the time series still displays some spikes, which could be indicative of outliers. We employ the z-score method to identify and correct potential outliers. This approach detects extreme values by measuring how many standard deviations a data point is from the mean. However, while this step reduced some variability, the time series still showed variance inconsistency.

```{r, outlier_detection1, echo = FALSE, warning = F}
# Calculate z-scores for the time series
z_scores <- (baseload_log_seasonal_diff_d - mean(baseload_log_seasonal_diff_d, na.rm = TRUE)) / sd(baseload_log_seasonal_diff_d, na.rm = TRUE)

# Set a threshold for outlier detection (commonly 3 standard deviations)
outliers <- which(abs(z_scores) > 3)

# Print the indices of the detected outliers
print(outliers)

# Replace outliers with NA or the median (imputation)
baseload_clean <- baseload_log_seasonal_diff_d
baseload_clean[outliers] <- NA  # Replacing with NA
baseload_clean <- na.approx(baseload_clean)  # Interpolating NA values

# Plot the cleaned time series
plot(baseload_clean, main="Cleaned Time Series After Z-Score Outlier Removal")

```

Since the z-score approach does not fully address the variance issues, we turn to the Interquartile Range (IQR) method. The IQR approach is more robust for detecting outliers in time series with non-normal distributions, as it focuses on the middle 50% of the data. 

```{r, outlier_detection2, echo = FALSE, warning = F}
# Calculate the IQR
Q1 <- quantile(baseload_log_seasonal_diff_d, 0.25, na.rm = TRUE)
Q3 <- quantile(baseload_log_seasonal_diff_d, 0.75, na.rm = TRUE)
IQR_value <- IQR(baseload_log_seasonal_diff_d, na.rm = TRUE)

# Define lower and upper bounds for outliers
lower_bound <- Q1 - 1.5 * IQR_value
upper_bound <- Q3 + 1.5 * IQR_value

# Detect outliers
outliers <- which(baseload_log_seasonal_diff_d < lower_bound | baseload_log_seasonal_diff_d > upper_bound)

# Replace outliers with NA or the median (imputation)
baseload_clean <- baseload_log_seasonal_diff_d
baseload_clean[outliers] <- NA  # Replacing with NA
baseload_clean <- na.approx(baseload_clean)  # Interpolating NA values

# Plot the cleaned time series
plot(baseload_clean, main="Cleaned Time Series After IQR Outlier Removal")
```

This method looks promising in identifying and treating the outliers, resulting in a more stable time series. We perform a decomposition of the time series after the IQR outlier removal to examine its components.

```{r, decomp_baseload_clean, echo = FALSE, warning = F}
# Decompose the time series
decomp_baseload_clean <- decompose(baseload_clean)

# Plot the decomposition
plot(decomp_baseload_clean)
```

The decomposition of the IQR approach of cleaning the time series still shows a trend. Hence, to address the remaining trend, we apply an additional round of differencing, hoping to remove the remaining trend.

```{r, 2_order_diff_bl, echo = FALSE, warning = F}
# Apply second-order differencing
baseload_log_diff_second <- diff(baseload_clean)

# Plot the second-order differenced series
plot(baseload_log_diff_second, main="Second-Order Differenced Baseload Time Series")
```

Again, the differenced time series looks promising but we will decompose it to ensure stationarity.

```{r, decomp_baseload_clean_2, echo = FALSE, warning = F}
# Decompose the time series
decomp_baseload_clean_2 <- decompose(baseload_log_diff_second)

# Plot the decomposition
plot(decomp_baseload_clean_2)
```

The decomposition of the differenced time series now looks stationary and to statistically verify stationarity, we conduct the ADF-test.

```{r, day-ahead baseload_adf, include = T, echo = FALSE, warning = F}
# Perform ADF test to check stationarity
adf.test(baseload_log_diff_second)
```

The ADF-test returns a p-value less than 0.01, confirming that the time series is now stationary.

#### Model Specification of Day-Ahead Prices

```{r, acf_pacf_bl_sec, echo = FALSE, warning = F}
# Plot ACF and PACF
acf(baseload_log_diff_second, lag.max = 1000, main="ACF of Stationary Series")
pacf(baseload_log_diff_second, lag.max = 1000, main="PACF of Stationary Series")

```

The ACF shows significant autocorrelation at various lags and the PACF exhibits various significant lags but is somewhat decaying. Specifically the slow decay in ACF may indicate that the series is not yet stationary, or it could be exhibiting long memory properties. Possible causes include under-differencing, remaining seasonality or long memory processes. Consulting the above decomposition of the second-order differenced time series, we suspect that there may still be some seasonal patterns in the differenced data, so we will further seasonally difference the the time series. 

```{r, diff_season_bl, echo = FALSE, warning = F}
# Diff seasonality
baseload_log_diff_third <- diff(baseload_log_diff_second, lag = 365)

plot(decompose(baseload_log_diff_third))
```


```{r, acf_pacf_bl_third, echo = FALSE, warning = F}
# Plot ACF and PACF
acf(baseload_log_diff_third, lag.max = 1000, main="ACF of Stationary Series")
pacf(baseload_log_diff_third, lag.max = 1000, main="PACF of Stationary Series")

```

After further inspection of the ACF and PACF, the same problem still persist, limiting the next steps on analyzing the time series. For illustrative purposes, we will commence with the forecast of the baseload prices, using the second-order differenced time seriesn and higher order AR(3) and MA(2) terms, fully understanding that this may result in the model failing the Ljung-Box test.

```{r, arima_bl, echo = T, warning = F, cache = T}
model_baseload <- Arima(baseload_log_diff_second, order = c(3, 1, 2),
                        seasonal = list(order = c(0, 1, 0), period = 365))
summary(model_baseload)

```

```{r, residuals_bl, echo = FALSE, warning = F}
tsdisplay(residuals(model_baseload))
Box.test(residuals(model_baseload), lag = 20, type = "Ljung-Box")
```

As anticipated, the Ljung-Box test has a very low p-value which indicates that we have missed some structures in our time series. The plot below shows the forecast of the second-order differenced time series.

```{r, forecast_bl_1, echo = FALSE, warning = F, cache = T}

# Forecast the next period
arima_forecast_baseload <- forecast(model_baseload, h = 100)
plot(arima_forecast_baseload)
```

If we were to continue the analysis, the next steps would involve reversing the transformations applied to achieve stationarity in order to interpret the forecasts on the original scale. This process includes integrating the forecasted values by  reversing the seasonal and non-seasonal differencing — using the last observed data points as starting values — and then applying the exponential function to undo the log-transformation. By doing so, we would obtain forecasted baseload values that are meaningful and comparable to the original data.

# Results

## Limitations

-cover general limitations

**Add text**

https://www.elcom.admin.ch/dam/elcom/de/dokumente/2023/berichtregelleistungundregelenergie2022.pdf.download.pdf/Bericht%20Regelleistung%20und%20Regelenergie.pdf

https://www.elcom.admin.ch/dam/elcom/de/dokumente/2024/taetigkeitsbericht2023.pdf.download.pdf/Taetigkeitsbericht_ElCom_2023-DE_Einzelseiten.pdf

Changes in procurement of control energy
https://www.youtube.com/watch?v=KYGUG217PYY


https://www.swissgrid.ch/en/home/newsroom/dossiers/crowd-balancing-platform.html

# Conclusion

What did we learn, what did we not learn, how does this relate to policymakers.

\newpage

# Biblioghraphy
