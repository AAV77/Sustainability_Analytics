---
title: "Evaluation of Variable Renewable Energy Source's 
contribution to cost of control energy"
author: "Del Conte, Küng, van Lengerich, Vayloyan "
date: "2024-08-03"
output:
  pdf_document:
    toc: yes
    toc_depth: 2
    number_sections: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
notes: footnotes
---

```{r, include = F, warning = F}
library(knitr)
library(readxl) #install packages first if not done so already
library(readr)
library(tidyr)
library(tidyquant)
library(lubridate)
library(ggplot2)
library(forecast)
library(tseries)
library(rugarch)
library(vars)
library(scales)
library(dplyr)
library(readr)
library(stringr)

setwd(dirname(rstudioapi::getSourceEditorContext()$path)) #setting directory
```

```{r, importing power prices, warning = F, include= F, cache= T}
sheets_after_2015 <- c("EnergieUebersichtCH-2015.xls",
                       "EnergieUebersichtCH-2016.xls", 
                       "EnergieUebersichtCH-2017.xls",
                       "EnergieUebersichtCH-2018.xls", 
                       "EnergieUebersichtCH-2019.xls",
                       "EnergieUebersichtCH-2020.xls"
                       )

sheets_after_2021 <- c("EnergieUebersichtCH-2021.xlsx",
                       "EnergieUebersichtCH-2022.xlsx",
                       "EnergieUebersichtCH-2023.xlsx",
                       "EnergieUebersichtCH-2024.xlsx"
                       )

# Empty list to store data frames
data_list <- list()

# Loop through the sheets and read each one for xls
for (s in sheets_after_2015) {
  # Read the Excel file
  df <- read_xls(s, sheet = "Zeitreihen0h15",)
  df <- df %>% select (1, 7,8,9,10, 22:25) 
  
  # Convert the timestamp column
  df[[1]] <- as.numeric(df[[1]])
  df$Timestamp <- as.POSIXct(df[[1]] * 86400,
                             origin = "1899-12-29 23:00:00",
                             tz = "Europe/Zurich")
  
  # Store the data frame in the list
  data_list[[s]] <- df %>% select(-1)
}

# Loop through the sheets and read each one for xlsx
for (s in sheets_after_2021) {
  # Read the Excel file
  df <- read_xlsx(s, sheet = "Zeitreihen0h15",)
  df <- df %>% select (1, 7,8,9,10, 22:25) 
  
  # Convert the timestamp column
  df$Timestamp <- as.POSIXct(df[[1]],
                             format = "%d.%m.%Y %H:%M",
                             tz = "Europe/Zurich")
  
  #remove first column
  df <- df %>% select(-1)
  
  # Set the column-names to match the xls data
  # Adjusting the slightly different spelling
  colnames(df) <- 
    colnames(data_list[["EnergieUebersichtCH-2015.xls"]])
  
  # Store the data frame in the list
  data_list[[s]] <- df
}

# Combine all data frames in the list into one
combined_data <- bind_rows(data_list)

combined_data <- combined_data %>% 
  filter(combined_data[[2]] != "kWh") # taking out the duplicated headers which
                                      # ended up in the dataframe
```

```{r, manipulations 1, warning = F, include= F, cache= T}
combined_data <- combined_data %>% 
  rename(
    pos_sec_amount_kwh = names(combined_data)[1], 
    neg_sec_amount_kwh = names(combined_data)[2],
    pos_ter_amount_kwh = names(combined_data)[3],
    neg_ter_amount_kwh = names(combined_data)[4],
    price_pos_sec_EUR_MWh = names(combined_data)[5],
    price_neg_sec_EUR_MWh = names(combined_data)[6],
    price_pos_ter_EUR_MWh = names(combined_data)[7],
    price_neg_ter_EUR_MWh = names(combined_data)[8]
    ) 

combined_data <- combined_data %>% 
    mutate(across(c(1:8), as.numeric)) # convert to numeric

combined_data <- combined_data %>% 
  mutate( #calculating costs of energy
  cost_pos_sec = (combined_data[[1]] / 1000)*combined_data[[5]], 
  cost_neg_sec = (combined_data[[2]] / 1000)*combined_data[[6]],  
  cost_pos_ter = (combined_data[[3]] / 1000)*combined_data[[7]],
  cost_neg_ter = (combined_data[[4]] / 1000)*combined_data[[8]]
  ) %>% 
  select(9, everything())  #rearranging
```


```{r, manipulations 2, warning = F, include= F, cache= T}
hourly_summary <- combined_data %>%
  # create a column 'hour' by rounding down to the nearest hour
  mutate(hour = floor_date(Timestamp, "hour")) %>%  
  group_by(hour) %>%  # Group by the new 'hour' column
  summarise(
    # Sum the energy amount columns
    pos_sec_amount_kwh = sum(pos_sec_amount_kwh, na.rm = TRUE),
    neg_sec_amount_kwh = sum(neg_sec_amount_kwh, na.rm = TRUE),
    pos_ter_amount_kwh = sum(pos_ter_amount_kwh, na.rm = TRUE),
    neg_ter_amount_kwh = sum(neg_ter_amount_kwh, na.rm = TRUE),

    # Sum the cost columns
    cost_pos_sec = sum(cost_pos_sec, na.rm = TRUE),
    cost_neg_sec = sum(cost_neg_sec, na.rm = TRUE),
    cost_pos_ter = sum(cost_pos_ter, na.rm = TRUE),
    cost_neg_ter = sum(cost_neg_ter, na.rm = TRUE),

    # Average the price columns
    avg_price_pos_sec_EUR_MWh = mean(price_pos_sec_EUR_MWh, na.rm = TRUE),
    avg_price_neg_sec_EUR_MWh = mean(price_neg_sec_EUR_MWh, na.rm = TRUE),
    avg_price_pos_ter_EUR_MWh = mean(price_pos_ter_EUR_MWh, na.rm = TRUE),
    avg_price_neg_ter_EUR_MWh = mean(price_neg_ter_EUR_MWh, na.rm = TRUE)
  ) %>%
  ungroup() %>%   # Ungroup to complete the operation
  rename(
  Timestamp    = hour #renaming for merging
  )
```


```{r, importing renwable share and grid load, include = F , warning = F, include= F}
# Importing the generation data per production type
gen_per_type_list <- c("Actual Generation per Production Type_201501010000-201601010000.csv",
                       "Actual Generation per Production Type_201601010000-201701010000.csv",
                       "Actual Generation per Production Type_201701010000-201801010000.csv",
                       "Actual Generation per Production Type_201801010000-201901010000.csv",
                       "Actual Generation per Production Type_201901010000-202001010000.csv",
                       "Actual Generation per Production Type_202001010000-202101010000.CSV",
                       "Actual Generation per Production Type_202101010000-202201010000.csv",
                       "Actual Generation per Production Type_202201010000-202301010000.csv",
                       "Actual Generation per Production Type_202301010000-202401010000.csv",
                       "Actual Generation per Production Type_202401010000-202501010000.csv")

# Initialize an empty dataframe to store the combined data
df_combined_type <- tibble()

# Loop through the different csv
for (s in gen_per_type_list) {
  # Read the csv
  df_gen_per_type <- read_csv(s, na = c("N/A", "", "n/e", "-"))
  
  # Combine the dataframes
  df_combined_type <- bind_rows(df_combined_type, df_gen_per_type)
  }

# Importing the grid load data
grid_load_list <- c("Total Load - Day Ahead _ Actual_201501010000-201601010000.csv",
                    "Total Load - Day Ahead _ Actual_201601010000-201701010000.csv",
                    "Total Load - Day Ahead _ Actual_201701010000-201801010000.csv",
                    "Total Load - Day Ahead _ Actual_201801010000-201901010000.csv",
                    "Total Load - Day Ahead _ Actual_201901010000-202001010000.csv",
                    "Total Load - Day Ahead _ Actual_202001010000-202101010000.csv",
                    "Total Load - Day Ahead _ Actual_202101010000-202201010000.csv",
                    "Total Load - Day Ahead _ Actual_202201010000-202301010000.csv",
                    "Total Load - Day Ahead _ Actual_202301010000-202401010000.csv",
                    "Total Load - Day Ahead _ Actual_202401010000-202501010000.csv")

# Initialize an empty dataframe to store the combined data
df_combined_load <- tibble()

# Loop through the different csv
for (s in grid_load_list) {
  # Read the csv
  df_load <- read_csv(s, na = c("N/A", "", "n/e", "-"))
  
  # Combine the dataframes
  df_combined_load <- bind_rows(df_combined_load, df_load)
  }


# Create timestamps for the dataframe (per type)
df_combined_type <- df_combined_type %>%
  mutate(
    # Extract the starting date-time part of the MTU column
    StartTimestamp = sapply(str_split(MTU, " - "), `[`, 1),
    Timestamp = suppressWarnings(
      dmy_hm(StartTimestamp, tz = "Europe/Zurich"))
    ) %>%
  select(-StartTimestamp) %>% 
  # Remove rows where Timestamp is NA (problem with daylight savings time)
  filter(!is.na(Timestamp)) %>% 
  # Remove duplicate rows (there are duplicate rows because of daylight savings 
  # time (time from 02:00 to 03:00 happens twice) -> only keep the first row)
  distinct(Timestamp, .keep_all = TRUE)


# Create timestamps for the dataframe (load)
df_combined_load <- df_combined_load %>%
  mutate(
    # Extract the starting date-time part of the MTU column
    StartTimestamp = sapply(str_split(`Time (CET/CEST)`, " - "), `[`, 1),
    Timestamp = suppressWarnings(
      dmy_hm(StartTimestamp, tz = "Europe/Zurich"))
    ) %>%
  select(-StartTimestamp) %>% 
  # Remove rows where Timestamp is NA (problem with daylight savings time)
  filter(!is.na(Timestamp)) %>% 
  # Remove duplicate rows (there are duplicate rows because of daylight savings 
  # time (time from 02:00 to 03:00 happens twice) -> only keep the first row)
  distinct(Timestamp, .keep_all = TRUE)


# Merging two combined dataframes on the timestamp
df_gen_load_raw <- full_join(df_combined_type, df_combined_load,
               by = "Timestamp") 


# Clean up combined df
df_gen_load <- df_gen_load_raw %>% 
  # Remove columns where all values are NAs (Fossil - brown coal for example)
  select(where(~ any(!is.na(.)))) %>% 
  # Remove column are (CH)
  # Remove columns conatining original time information and area
  select(-c("Area", "MTU", "Time (CET/CEST)"))

# Adding VRES (percentage Swiss (solar + wind) production / load on grid)
df_gen_load <- df_gen_load %>%
  mutate(VRES_percent = (`Solar  - Actual Aggregated [MW]` + `Wind Onshore  - Actual Aggregated [MW]`) / `Actual Total Load [MW] - BZN|CH`)
```


```{r, join, include= F, warning = F }
df_combined <- left_join(hourly_summary, df_gen_load, by = "Timestamp") 
# merging on the hour
```


```{r, adding total cost, include = F, warning = F}
# Add total cost
df_combined <- df_combined %>% 
  #calculating total cost by summing all costs
  mutate(total_cost_EUR = 
           cost_pos_sec+cost_neg_sec+cost_pos_ter+cost_neg_ter)

# Save the lines with NA values in VRES or Total cost -> 57 lines / hours
df_na_output <- df_combined %>% 
  filter(is.na(VRES_percent) | is.na(total_cost_EUR))

# Exclude the lines with NA values in VRES or Total cost
df_combined <- df_combined %>% 
  filter(!is.na(VRES_percent) & !is.na(total_cost_EUR)) 

# Rearrange and rename rows in df_combined
d.h <- df_combined %>% 
  select(Timestamp, VRES_percent, total_cost_EUR,
         total_load_MW = `Actual Total Load [MW] - BZN|CH`,
         cost_pos_sec_EUR = cost_pos_sec, cost_neg_sec_EUR = cost_neg_sec,
         cost_pos_ter_EUR = cost_pos_ter, cost_neg_ter_EUR = cost_neg_ter,
         pos_sec_amount_kwh, neg_sec_amount_kwh,
         pos_ter_amount_kwh, neg_ter_amount_kwh,
         avg_price_pos_sec_EUR_MWh, avg_price_neg_sec_EUR_MWh,
         avg_price_pos_ter_EUR_MWh, avg_price_neg_ter_EUR_MWh,
         CH_solar_generation_actual_MW = `Solar  - Actual Aggregated [MW]`,
         CH_wind_onshore_generation_actual_MW =
           `Wind Onshore  - Actual Aggregated [MW]`,
         everything())

# removing clutter
remove(combined_data, data_list, df, df_load, df_combined,
       df_combined_load, df_combined_type, 
       df_gen_load, df_gen_per_type, hourly_summary)
```


```{r, Test cost of 2020, warning = F, include= F}
sums_2020 <- d.h %>%
    filter(year(Timestamp) == 2020) %>%
    summarise(across(where(is.numeric), ~ sum(.x, na.rm = FALSE)))
# Comparison with report shows same numbers
```


```{r, daily-data_load, include = F, warning = F}
# Load the datasets
energy_production <- read_csv("ogd104_stromproduktion_swissgrid.csv")
energy_prices <- read_csv("ogd106_preise_strom_boerse.csv")

# Reshape the energy production data to have one column per energy source
energy_production <- energy_production %>%
  pivot_wider(names_from = Energietraeger, values_from = Produktion_GWh, values_fill = 0)

# Merge the reshaped energy production data with the energy prices data
d.d <- merge(energy_prices, energy_production, by="Datum", all.x=TRUE)

# Fill any remaining NAs with 0 (in case there were dates in energy_prices not in energy_production)
d.d[is.na(d.d)] <- 0
```

```{r, daily-data_rename variables, include = F, warning = F}

# Rename columns in dataset
d.d <- d.d %>%
  rename(
    Date = Datum,
    Hydro_GWh = Flusskraft,
    Nuclear_GWh = Kernkraft,
    Storage_GWh = Speicherkraft,
    Thermal_GWh = Thermische,
    Photovoltaic_GWh = Photovoltaik,
    Wind_GWh = Wind
  )
```

```{r, daily_data-add vres and non-vres, include = F, warning = F}

# Add new columns 'VRES_GWh' and 'Non_VRES_GWh' to d.d
d.d <- d.d %>%
  mutate(
    VRES_GWh = Photovoltaic_GWh + Wind_GWh,
    Non_VRES_GWh = Hydro_GWh + Nuclear_GWh + Storage_GWh + Thermal_GWh
  )

# View the first few rows to confirm the new columns
head(d.d)

# remove not needed data
remove(energy_production, energy_prices)
```

\newpage

# Introduction

Governments and scientists around the world largely agree on the need for a low-carbon electricity production. In the Sustainable Development Goal 7 (affordable and clean energy)[^sdg]. A step in this direction is the construction, installation and connection of Renewable Energy Sources (RES) such as Hydropower, Wind and Solar to the electricity grid. These produce little to no direct emissions while supplying electricity and have life cycle carbon costs far lower than fossil fuels (@LCElectricity). A substrate of RES are so called Variable-RES (VRES), which are electricity sources whose production cannot easily be increased or decreased by the operator. Wind and Solar both rely on meteorological conditions, if these are not right, nothing is produced. This is contrary to most other sources whose production can be increased or decreased according to market needs. Although the time it takes to ramp production up or down can still present a challenge. 

[^sdg]: <https://sdgs.un.org/goals>

The lack of direct control over production with VRES presents a huge challenge to the adoption of such sources, since there is no large scale energy storage available. Battery Storage, Pumped Hydro and Heat Pumps do store energy, but currently these forms of power would not be able to power a country for even a couple of hours.

The addition of electricity from VRES has the possibility to:

1.  Drastically lower electricity prices.
2.  Increase price volatility.
3.  Rapidly change the quantity of electricity available on the grid in either direction.

The reason for the first claim is that VRES has practically no marginal costs. No fuel rods, pumping, gas or other notable inputs are required to produce solar and wind energy. This means producers of VRES will bid their energy at almost any price. If they cannot profit - maximize, they will loss - minimize.

The second claim is the case because meteorological events tend to be fairly consistent across an area. When one wind / solar farm is producing, so are the ones around it. This means there is huge downward pressure on prices during periods of favorable VRES production and none at all during unfavorable conditions.

The third claim is particularly relevant for control energy's price. The reason for this is described in the next two points.

## Control Energy

One aspect of electricity prices is the price paid for control energy. This is the short term (up to 15 min) electricity supply used to keep the grid at a constant frequency, due to unforeseen changes in supply and demand. It is necessary since the amount of energy consumed and produced must always be identical. The increased penetration of VRES, which cannot be steered by operators means that the purchase of such energy should be increasing with more VRES installed on the grid in recent years.

## Relevance

If the amount of control electricity purchased by Transmission System Operators increases then this means costs will be passed down to consumers. Since electricity is a primary input in the economy, higher prices will be reflected across the vast majority of goods and services. This is an undesirable outcome. It is therefore important for policymakers, stakeholder and the public to understand the drivers of increased prices of control energy. This is particularly important in the context of the SDG 7, which stresses the need for clean energy. Policymakers must understand the impact of increasing the share of VRES on the grid to be aware of potential economic and political backlash of their decisions.

## Literature Review

The academic literature on VRES's effect on control energy is fairly sparse. Using the search terms "control energy" and "(variable) renewable energy", only one relevant paper was found. @hirth_control_2013 have found that the inclusion of VRES from 2008-2013 decreases procurement cost of control power by 50%, presumably permitting lower prices for end consumers. The broader literature on the effect of VRES on electricity supply is broader.

These areas generally focus on both variability of supply and prices. Amongst them: @pereiradasilva2019 who use EGARCH time series and regression while studying the Iberian power market; @frauendorfer2018 who find that the Swiss are "importing" lower German power prices during peak solar production, as Germany has much more solar energy sources than the Swiss. Finally, the authors @dong2019 find that the Swedish have more stable prices due to the relativley high proportion of non variable fossil and hydropower than the Danes, who are more reliant on VRES in the form of wind and solar. Other studies in the area are more conflicted, such as @rintamäki2017 who compare Germany and Danish prices and wind that the effect of increasing wind production on day ahead prices is not constant. The point is that increasing VRES leads to variability in supply, which presumably means more cost for balancing out an unpredictable supply when the predictions are wrong.

It is the purpose of this study to see whether and if so, to what extent renewable energy sources are related to increasing costs of control energy.

\newpage

# Data Sources
## Data source for control energy
Swissgrid provides a variety of data about electricity in Switzerland, which they make publicly available.[^Swissgrid1] They provide the data in intervals of 15\ minutes. It can be downloaded as a .xls/or/.xlsx file per year. The time period of the data used in the following analysis ranges from the beginning of 2015 until the end of July 2024.
They provide data about the electricity production and consumption for Switzerland and for the individual cantons. Additionally, they also provide the information about control energy (amount and prize), split up in positive and negative as well as secondary and tertiary. There is no data provided about primary control energy.
They state that "The data are reliable from 6 months onwards, until then the partners from the electricity sector who provide Swissgrid with the data can still claim changes."[^Swissgrid1]. This should be kept in mind for the time period of 2024.

[^Swissgrid1]: <https://www.swissgrid.ch/en/home/operation/grid-data/generation.html>

The following table shows an excerpt of the data provided by Swissgrid with an example value.

```{r Table-Swissgrid-Data, include = TRUE, echo=FALSE, message=FALSE, warning=FALSE}

# Read the column names and one sample row from the Excel file
data.example <- read_excel("EnergieUebersichtCH-Example-Data.xlsx",
                           sheet = "Zeitreihen0h15",
                           col_names = FALSE,
                           range = "A1:BM3")

# function to handle splitting of column names
extract_english_part <- function(text) {
  parts <- strsplit(text, "&Linebreak%")[[1]]
  if (length(parts) >= 2) {
    return(parts[2])
  } else {
    return(text)
  }
}

# Extract English column names
v.english_column_names <- sapply(data.example[1, ], extract_english_part)

# Get units and example data row
v.units <- unlist(data.example[2, ])
v.example_data_row <- unlist(data.example[3, ])

# Combine into a new data frame
d.info_df <- data.frame(Column_Name = v.english_column_names,
                        Type = v.units,
                        Example_Value = v.example_data_row)

# Create kable, which will be output
kable(d.info_df, row.names = FALSE,
      caption = "Data provided from Swissgrid",
      col.names = c("column name", "type", "example value"))
```

## Data Source for generation share of wind and solar (hourly)
To obtain the percentage of VRES data from the transparency platform from the European Network of Transmission System Operators for Electricity (enstsoe) was used.[^entsoeSource1] After creating an account the data about grid forecast and load ("Actual Total Load [6.1.A]" and "Day-ahead Total Load Forecast [6.1.B]") and the actual generation per production type ("Aggregated Generation per Type [16.1.B&C]") can be obtained. They provide the data in intervals of 1\ hour and the data can be downloaded as a .csv file with a time span of 1 year. The data was obtained for the same time period as the data from Swissgrid and combined for further analysis.

[^entsoeSource1]: https://transparency.entsoe.eu/

```{r Table-Entsoe-Data, include = TRUE, echo=FALSE, message=FALSE, warning=FALSE}
# Extract column names
v.column_names <- c(colnames(df_gen_load_raw))

# Get example data row
v.example_data_row <- unlist(as.vector(df_gen_load_raw[10, ]))

# Combine into a new data frame
d.info_df <- data.frame(Column_Name = v.column_names,
                        Example_Value = v.example_data_row)

# Create kable, which will be output
kable(d.info_df, row.names = FALSE,
      caption = "Data provided from entsoe",
      col.names = c("column name", "example value"))
```

Many columns could be omitted after loading since they contained only "NA" values for every row (for example "Fossil Brown coal/Lignite - Actual Aggregated [MW]" which are not used to produce electricity in Switzerland).

Using this data the percentage of variable renewables (VRES) was calcuted using the following formula
$$
\text{`VRES\_percent`} = \frac{\text{`Solar-Actual Aggregated [MW]`} + \text{`Wind Onshore-Actual Aggregated [MW]`}}{\text{`Actual Total Load [MW] - BZN|CH)`}}
$$

## Data Source for generation share of wind and solar (daily)
**Will follow**
...


# Overview Variable Renewable Energy Sources 


```{r Wind and Solar, include = TRUE, echo = FALSE}

# Plot the Daily Generation with wind in the foreground and solar in the background
ggplot(d.d) + 
  # Solar generation in the background
  geom_line(aes(x = Date, y = Photovoltaic_GWh, color = "Solar"), size = 1) + 
  # Wind generation in the foreground
  geom_line(aes(x = Date, y = Wind_GWh, color = "Wind"), size = 1) + 
  ggtitle("Wind and Solar Generation over Time") +
  xlab("Date") +
  ylab("Generation (GWh)") +
  scale_color_manual(values = c("Wind" = "blue", "Solar" = "orange")) + 
  theme_minimal() +
  labs(color = "Generation Type")

#Weekly Moving Average
# Plot wind in the foreground and solar in the background
ggplot(d.d) + # Solar generation in the background
  geom_ma(ma_fun= SMA, n = 7, aes(x = Date, y = Photovoltaic_GWh, color = "Solar"), size = 1) +

# Wind generation in the foreground
  geom_ma(ma_fun= SMA, n = 24, aes(x = Date, y = Wind_GWh, color = "Wind"), size = 1) + 
  ggtitle("Wind and Solar Generation Moving Average over Time") +
  xlab("Time") +
  ylab("Generation (MW)") +
  scale_color_manual(values = c("Wind" = "blue", "Solar" = "orange")) + 
  theme_minimal() +
  labs(color = "Generation Type")

###################

# Plot the hourly data with wind in the foreground and solar in the background
ggplot(d.h) + 
  # Solar generation in the background
  geom_line(aes(x = Timestamp, y = CH_solar_generation_actual_MW, color = "Solar"), size = 1) + 
  # Wind generation in the foreground
  geom_line(aes(x = Timestamp, y = CH_wind_onshore_generation_actual_MW, color = "Wind"), size = 1) + 
  ggtitle("Wind and Solar Generation over Time") +
  xlab("Date") +
  ylab("Generation (GWh)") +
  scale_color_manual(values = c("Wind" = "blue", "Solar" = "orange")) + 
  theme_minimal() +
  labs(color = "Generation Type")

# Daily Moving Average
# Plot the filtered data with wind in the foreground and solar in the background
ggplot(d.h) + 
  # Solar generation in the background
  geom_ma(ma_fun= SMA, n = 24, aes(x = Timestamp, y = CH_solar_generation_actual_MW, color = "Solar"), size = 1) +

# Wind generation in the foreground
  geom_ma(ma_fun= SMA, n = 24, aes(x = Timestamp, y = CH_wind_onshore_generation_actual_MW, color = "Wind"), size = 1) + 
  ggtitle("Wind and Solar Generation Moving Average over Time") +
  xlab("Time") +
  ylab("Generation (MW)") +
  scale_color_manual(values = c("Wind" = "blue", "Solar" = "orange")) + 
  theme_minimal() +
  labs(color = "Generation Type")


  
```

```{r VRES, include = TRUE, echo = FALSE}


# VRES_percent Range

min_VRES <- min(d.h$VRES_percent, na.rm = TRUE)
max_VRES <- max(d.h$VRES_percent, na.rm = TRUE)

min_VRES
max_VRES



# Plot the filtered data
ggplot(d.h, aes(x = Timestamp, y = VRES_percent * 100)) + 
  geom_line(color = "blue") + 
  ggtitle("VRES Percent over Time") +
  xlab("Time") +
  ylab("VRES percent [%]") +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) + 
  theme_minimal()

# Moving Average
ggplot(d.h)+ 
  geom_ma(ma_fun= SMA, n = 24, aes(x = Timestamp, y = VRES_percent* 100)) + 
  ggtitle("VRES_percent Over Time") +
  xlab("Time") +
  ylab("VRES percent [%]") +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) + 
  theme_minimal()
```

The above graph displays VRES\_percent (Variable Renewable Energy Sources as a percentage of total energy demand) over time. A clearly cyclical wave pattern can be identified, indicating the presence of seasonality, which is expected due to the seasonal nature of wind and solar energy production. This seasonality reflects the fluctuations in renewable energy availability throughout the year.

the maximum value has been pushed up noticeably every year since 2020 and almost reached 60%. When looking at the moving average, where each dot represents the average contribution over a 24 hour period, this share is lowered significantly, still reaching a contribution of 20% to the daily production in the last recorded summer of 2024. 


```{r, Cost of Secondary Control Energy, include = TRUE}


# Cost aggregated by Year

# Convert the 'Timestamp' column to POSIXct format
d.h$Timestamp <- as.POSIXct(d.h$Timestamp, format = "%Y-%m-%d %H:%M:%S")

# Extract the year from the 'Timestamp' column
d.h$year <- year(d.h$Timestamp)

# Group by 'year' and summarize the total cost for each year
df_yearly_cost <- d.h %>%
  group_by(year) %>%
  summarise(total_cost = sum(cost_neg_sec_EUR, na.rm = TRUE))


# Filter out the year 2024 and group by 'year', then summarize the total cost for each year
df_yearly_cost <- d.h %>%
  filter(year != 2024) %>%  # Exclude the year 2024
  group_by(year) %>%
  summarise(total_cost = sum(cost_neg_sec_EUR, na.rm = TRUE)) #y-axis with 'Mio' and commas

# Reshape the data into long format, selecting all four relevant columns
d.h_long <- d.h %>%
  filter(year != 2024) %>%  # Exclude the year 2024
  pivot_longer(cols = c(cost_pos_sec_EUR, cost_neg_sec_EUR, cost_pos_ter_EUR, cost_neg_ter_EUR), 
               names_to = "cost_type", values_to = "cost_value")

# Group by 'year' and 'cost_type', then summarize the total cost for each
df_yearly_cost <- d.h_long %>%
  group_by(year, cost_type) %>%
  summarise(total_cost = sum(cost_value, na.rm = TRUE)) %>%
  ungroup()

# Create a bar plot for the sum of costs per year, with different colors for each 'cost_type'
ggplot(df_yearly_cost, aes(x = as.factor(year), y = total_cost / 1e6, fill = cost_type)) +  # Y-axis in millions
  geom_bar(stat = "identity", position = "dodge", color = "black") +  # Dodge to separate the bars
  ggtitle("Total Costs of Secondary and Tertiary Control Energy per Year in EUR") +
  xlab("Year") +
  ylab("Total Cost [EUR]") +
  scale_y_continuous(labels = label_number(suffix = " Mio", big.mark = ",")) +  # Format y-axis

  # Use the correct order of colors and labels according to the levels of cost_type
  scale_fill_manual(values = c("skyblue2", "lightblue1", "gold", "yellow"), 
  breaks = c("cost_pos_sec_EUR", "cost_neg_sec_EUR", "cost_pos_ter_EUR", "cost_neg_ter_EUR"),
  labels = c("+ Sec.", "- Sec.", "+ Ter.", "- Ter.")) +  # Custom colors and labels

  theme_minimal() +
  theme(legend.title = element_blank())  # Hide the legend title

# Identify exact duplicate rows
duplicate_rows <- d.h[duplicated(d.h) | duplicated(d.h, fromLast = TRUE), ]
duplicate_rows

```

This plot visualizes the total yearly "costs" (gain in the case of negative values) in Euro of secondary and tertiary control energy (positive and negative) from 2015 to 2023. The plot highlights trends in the costs associated with these control energy types, it is clearly visible that these total costs have risen in the last years, seemingly coinciding with the rise of solar energy production seen in our Data. To further analyze this relationship the next chapter will dive deeper into the Analysis using Time series.


# Control Costs (Time series)
## 3. Time Series of Hourly Data
### 3.1. Visualization of Control Costs

```{r, vres ts prep1, include = FALSE, warning = F}
# Convert the Timestamp column to a Date-Time object
d.h$Timestamp <- as.POSIXct(d.h$Timestamp, format="%Y-%m-%d %H:%M:%S")

# Replace NAs in 'VRES_percent' with zero
d.h$VRES_percent[is.na(d.h$VRES_percent)] <- 0

# Convert VRES_percent into a time series object
VRES_ts <- ts(d.h$VRES_percent, start=c(2015, 1), frequency=24*365.25)  # Assuming hourly data
```

```{r, plot ts of control cost, echo = FALSE, warning = F, message = F}

# Create the plot for VRES_percent with a linear trend line
ggplot(d.h, aes(x = as.Date(Timestamp), y = total_cost_EUR)) +
  geom_line(color = "darkblue") +                     
  geom_smooth(method = "lm", color = "black", se = FALSE) +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
  labs(title = "Cost of Control Energy Over Time",
       x = NULL, 
       y = "Cost in EUR per MWh")
```

The first plot illustrates the cost of control energy over time, measured in EUR per MWh, from 2015 through 2024. The x-axis represents the time period, while the y-axis reflects the control energy costs in EUR. The graph reveals an overall increasing trend in control costs as time progresses, with periods of volatility that become more pronounced starting in late 2020. Although the costs were relatively stable from 2015 until 2020, with only minor spikes, a noticeable rise in both the frequency and magnitude of cost fluctuations is observed from 2021 onwards. This suggests that control energy costs became more volatile, with significant spikes emerging around 2022 and peaking in late 2023 and early 2024.

One notable aspect of the data is the presence of multiple sharp peaks, indicating sudden surges in costs, which likely correspond to times of increased demand for control energy or variability in renewable energy generation. These peaks, reaching prices beyond EUR 7.5 million per MWh, imply high operational costs during these periods. Additionally, there are moments where the costs drop to zero or even become negative. Negative costs could imply that Swissgrid occasionally earns money, likely through balancing mechanisms when energy supply exceeds demand, thus allowing the sale of excess energy to other countries.

### 3.2. Decomposition of Control Costs

```{r, costs ts prep, include = FALSE, warning = F}
# Convert the Timestamp column to a Date-Time object
d.h$Timestamp <- as.POSIXct(d.h$Timestamp, format="%Y-%m-%d %H:%M:%S")

# Replace NAs in 'total_cost_EUR' with zero
d.h$total_cost_EUR[is.na(d.h$total_cost_EUR)] <- 0

# Convert total_cost_EUR into a time series object
total_cost_EUR_ts <- ts(d.h$total_cost_EUR, start = c(2015, 1), end = c(2024, 8), frequency=24*365.25)
```

```{r, costs additive decomposition, echo = FALSE, warning = F}

# Decompose the time series
cost_decomposed <- decompose(total_cost_EUR_ts)
plot(cost_decomposed)
```

The  decomposition into trend, seasonal, and remainder components provides insights into the underlying structure of the control cost data. The trend component reveals an upward trajectory starting in late 2020, peaking in mid-2023, and slightly declining towards the end of the observation period. This indicates that control costs were steadily increasing over time. The seasonal component exhibits recurring peaks and troughs, which suggests the presence of consistent, cyclical patterns in the control costs. These seasonal fluctuations could be linked to predictable changes in energy demand or production patterns, such as variations in solar and wind power generation.
The remainder (random) component still displays a substantial amount of unexplained variance, especially towards the later years of the time series. There is notable volatility in this component, which could be attributed to external factors or events not captured by the trend or seasonality, such as sudden shifts in energy market conditions or unexpected changes in demand. Given this, while the decomposition successfully highlights the importance of the trend and seasonal components, the remainder indicates a significant level of residual variability that could require further exploration. We believe that exogenous factors, like the war in the Ukraine, have contributed to increased noise in the remainder, starting in 2022. To control for these factors, in the next section, we will consider the time period up to end of 2021.

### 3.3. Stationarity of Control Costs

For the time series analysis of control costs, achieving stationarity is important to ensure valid modeling results. Initially, the original time series showed signs of non-stationarity, with an increasing trend and rising variance over time. This non-constant behavior is particularly evident due to the sharp cost increases in certain periods. Given the multiplicative nature of the data, a log transformation was first applied to stabilize the variance, addressing the large fluctuations in the original series.

```{r, differencing of day-ahead 1, echo = FALSE, warning = FALSE}
# Reflect period until end of 2021
total_cost_EUR_ts <- ts(d.h$total_cost_EUR, start = c(2015, 1), end = c(2021, 12), frequency=24*365.25)

# Apply log transformation (add a small constant to avoid log(0) issues)
costs_log <- log(total_cost_EUR_ts + 1e-6)

# Apply first-order differencing to remove the trend
costs_log_diff <- diff(costs_log, differences = 1)
sum(is.na(costs_log_diff))
costs_log_diff <- na.approx(costs_log_diff)
sum(is.na(costs_log_diff))

# Plot the differenced series
plot(costs_log_diff, main="Differenced Total Costs Time Series")

```

Following the log transformation, first-order differencing was applied to remove the trend from the time series. While this step successfully eliminated much of the trend, the resulting series still showed signs of variation over time, indicating the presence of seasonality. The plot of the differenced series showed reduced but not entirely constant variance, suggesting that further adjustments were needed.

```{r, differencing of day-ahead 2, echo = FALSE, warning = FALSE}
# Apply seasonal differencing (assuming yearly seasonality with a frequency of 365)
costs_log_diff_seasonal <- diff(costs_log_diff, lag = 365)

# Plot the seasonally differenced series
plot(costs_log_diff_seasonal, main="Seasonally Differenced Total Costs Time Series")

```

To address the cyclical nature of the data, seasonal differencing with a lag of 365 (corresponding to annual seasonality) was applied. This step accounted for recurring yearly patterns, resulting in a more stationary time series. The second plot, "Seasonally Differenced Total Costs Time Series," demonstrates that the variance has been more effectively stabilized compared to the non-seasonally differenced series.

```{r, costs adf, echo = FALSE, warning = FALSE}

# Perform Augmented Dickey-Fuller test
adf.test(costs_log_diff_seasonal)
```

Finally, an Augmented Dickey-Fuller (ADF) test was performed on the seasonally differenced series, yielding a p-value smaller than 0.01. This result indicates that the null hypothesis of non-stationarity can be rejected with high confidence, confirming that the seasonally differenced series is stationary.The combined use of log transformation, first-order differencing, and seasonal differencing ensures that the time series is stationary. This stationarity is crucial for the validity of subsequent modeling, particularly when analyzing the control costs up to the end of 2021 to avoid confounding effects from external shocks like the war in Ukraine.

### 3.4. Visualization of Variable Renewable Energy Sources (VRES) Control Energy

```{r, plot ts of vres percent, echo = FALSE, warning = F}

# Create the plot for VRES_percent with a linear trend line
ggplot(d.h, aes(x = as.Date(Timestamp), y = VRES_percent)) +
  geom_line(color = "darkgreen") +                     # Line plot of VRES_percent
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Add linear trend line
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
  labs(title = "VRES Percentage Over Time",
       x = NULL, 
       y = "VRES Percent")
```

The time series plot of Variable Renewable Energy Sources (VRES) percentage over time illustrates the proportion of VRES in the overall energy mix from 2015 through 2024. The x-axis represents time, while the y-axis shows the percentage of VRES, which fluctuates seasonally throughout the observed period. The data displays a clear seasonal pattern, with recurring peaks and troughs each year, likely tied to natural variations in solar and wind power generation. There is also a discernible upward trend, indicating a steady increase in the share of VRES over time, especially from 2020 onwards. This growth reflects the increasing penetration of renewable energy into the grid. The spikes and seasonal fluctuations suggest periods of high renewable generation, with sharp increases likely corresponding to periods of favorable weather conditions for solar and wind energy production. This trend will be further examined through decomposition to better understand the underlying components of the series.

### 3.5. Decomposition of VRES Control Energy

```{r, vres ts prep2, include = FALSE, warning = F}
# Convert the Timestamp column to a Date-Time object
d.h$Timestamp <- as.POSIXct(d.h$Timestamp, format="%Y-%m-%d %H:%M:%S")

# Replace NAs in 'VRES_percent' with zero
d.h$VRES_percent[is.na(d.h$VRES_percent)] <- 0

# Convert VRES_percent into a time series object
VRES_ts <- ts(d.h$VRES_percent, start = c(2015, 1), end = c(2024, 8), frequency=24*365.25)
```

The below plot shows the decomposition of the VRES time series. The observed panel shows seasonal peaks occurring annually, reflecting the cyclical nature of renewable energy generation. The trend component shows a relatively flat trajectory until 2019, after which there is a noticeable upward shift, indicating a substantial increase in VRES share from 2020 onwards. While this upward trend aligns with the growing share of renewable energy sources in the grid, especially solar and wind energy, it is unclear to us at this point whether this sharp increase is due to the heavy ramp-up of VRES or other factors contributing to the surge, such as different calculation methods.

```{r, vres additive decomposition, echo = FALSE, warning = FALSE}
# Decompose the time series
VRES_decomposed <- decompose(VRES_ts)
plot(VRES_decomposed)
```

The seasonal component exhibits a clear and consistent annual pattern, with large, predictable peaks occurring each year. These peaks are indicative of the regular variation in renewable energy production, likely driven by seasonal factors such as weather patterns, which affect solar radiation and wind speeds. The random component shows some variations, indicating that there may be structures int he data that is not captured by the trend and seasonal components. In fact, the random component does show increased variability in the later years, which may correspond to irregularities or external shocks affecting renewable generation.

Given the observed trend and seasonality, the analysis of VRES' impact on control costs will focus on the data up to the end of 2021, thereby excluding the post-2021 period where external factors (such as the war in Ukraine) may have contributed to increased volatility.

### 3.6. Stationarity of VRES Control Energy

We are now turning to the stationarity analysis, which will prepare the data for use in a vector autoregression (VAR) model and Granger cusality test aimed at forecasting control costs using VRES as a key predictor.

```{r, vres adf1, echo = FALSE, warning = F}

# Perform Augmented Dickey-Fuller test
adf.test(VRES_ts)
```

The Augmented Dickey-Fuller test of the VRES time series has a p-value of 0.01 although the decomposition clearly shows a trend, seasonality and also a change in randomness. We suspect a decomposition of a multiplicative time series might help. A multiplicative decomposition assumes that the components (trend, seasonality, and noise) interact in a multiplicative manner. This is often suitable when the variability of the time series increases as the level of the series increases, which might be indicated by the trend and seasonal patterns with the overall level.

Applying a log transformation to the data can stabilize the variance, which often makes the series more appropriate to decomposition or modeling. The log-transformation essentially converts a multiplicative relationship into an additive one.

```{r, vres multiplicative decomposition, echo = FALSE, warning = F}

# Apply log transformation (add a small constant to avoid log(0) issues)
VRES_log <- log(VRES_ts + 1e-6)

# Decompose the log-transformed time series
VRES_log_decomposed <- decompose(VRES_log)
plot(VRES_log_decomposed)

```

The decomposition of the log-transformed series still reveals a clear upward trend and significant seasonality, indicating that the series is not yet stationary despite an initial low p-value from the Augmented Dickey-Fuller test. This suggests that, while the variance was stabilized, the time series still contains structural components (trend and seasonal patterns) that need to be addressed. Therefore, the next steps involve applying first-order differencing to remove the underlying trend and seasonal differencing to eliminate cyclical variations. These transformations will help ensure the series is stationary.

```{r, vres differencing, echo = FALSE, warning = F}
# Apply first-order differencing to the log-transformed series
VRES_log_diff <- diff(VRES_log)

# Plot the differenced series
# plot(VRES_log_diff, main="Differenced Log-Transformed VRES Time Series")

# Apply seasonal differencing
VRES_log_seasonal_diff <- diff(VRES_log_diff, lag = 365)
sum(is.na(VRES_log_seasonal_diff))

# Plot the seasonally differenced log-transformed series
plot(VRES_log_seasonal_diff, main="Seasonally Differenced Log-Transformed VRES Time Series")

VRES_log_seasonal_diff_decomp <- decompose(VRES_log_seasonal_diff)
plot(VRES_log_seasonal_diff_decomp)
```

The resulting seasonally differenced, log-transformed series exhibits fluctuations around a constant mean with stable variance, as shown in the "Seasonally Differenced Log-Transformed VRES Time Series" plot. The decomposition of the differenced series confirms the absence of any significant remaining trend or seasonal patterns, with most variation captured in the random component. To verify stationarity, an Augmented Dickey-Fuller test was conducted, yielding a test statistic of -65.948 and a p-value smaller than 0.01. This result also rejects the null hypothesis of non-stationarity, indicating that the series is now stationary. The series is now ready for further analysis, such as Vector Autoregression (VAR), to assess its relationship with control costs.

```{r, stationarity vres, echo = FALSE, warning = TRUE}

adf.test(VRES_log_seasonal_diff)
```

```{r, vres sarima, include = FALSE, echo = FALSE, warning = F}

# Fit a SARIMA model using auto.arima
#sarima_model_h <- auto.arima(VRES_ts, seasonal = TRUE)

# Summary of the SARIMA model
#summary(sarima_model_h)

# Check residuals of the SARIMA model
#checkresiduals(sarima_model_h)

```

```{r, vres forecasting, include = FALSE, echo = FALSE, warning = F}
# Forecast the next 365 periods (adjust as needed)
#sarima_forecast_h <- forecast(sarima_model_h, h = 365)

# Plot the forecast
#plot(sarima_forecast_h)

```

### 3.7. Vector Autoregression (VAR) of VRES Impact on Total Control Costs

The next step in the analysis is to apply a Vector Autoregression (VAR) model to assess the linear interdependencies between time series. In this case, the VAR model will be used to analyze the dynamic relationship between VRES and control costs. By incorporating both the stationary VRES and control cost time series, the VAR model will help identify how changes in VRES affect control costs over time while accounting for the lagged effects of each variable on the other. We hope to provide insights into the impact of renewable energy integration on the grid's operational costs. We start by determining the optimal lag length.

```{r, align length time series, echo = FALSE, warning = FALSE}
# Reflect period until end of 2021
VRES_ts <- ts(d.h$VRES_percent, start = c(2015, 1), end = c(2021, 12), frequency=24*365.25)

# Apply log transformation (add a small constant to avoid log(0) issues)
VRES_log <- log(VRES_ts + 1e-6)

# Apply first-order differencing to the log-transformed series
VRES_log_diff <- diff(VRES_log)

# Apply seasonal differencing
VRES_log_seasonal_diff <- diff(VRES_log_diff, lag = 365)

# Check length
length(costs_log_diff_seasonal)
length(VRES_log_seasonal_diff)
```

```{r, lag length var, echo = TRUE, warning = F}
# Check for NAs
sum(is.na(costs_log_diff_seasonal))  # Check for NAs in costs_log_diff
sum(is.na(VRES_log_seasonal_diff))  # Check for NAs in VRES_log_seasonal_diff

# Determine lag length
VARselect(cbind(costs_log_diff_seasonal, VRES_log_seasonal_diff), lag.max = 10, type = "const")
```

The lag length selection process indicates that the optimal lag length is 10 according to all criteria (AIC, HQ, SC, and FPE). This suggests that incorporating 10 lags will provide the best model fit while capturing the dynamics between the differenced control costs and VRES time series. With this optimal lag length determined, the next step is to estimate the VAR model and analyze the interactions between the variables.

```{r, var model, echo = TRUE, warning = FALSE}
var_model <- VAR(cbind(costs_log_diff_seasonal, VRES_log_seasonal_diff), 
                 p = 10, type = "const")
summary(var_model)

```

The results of the VAR model estimation provide valuable insights into the dynamic relationship between control costs and VRES. For the equation predicting control costs (costs_log_diff_seasonal), several lags of the VRES variable are significant. Specifically, VRES at lags 1, 4, 6, 7, and 10 have significant coefficients, indicating that changes in VRES have both immediate and delayed effects on control costs. For instance, the negative coefficient for the first lag of VRES (-0.0139, p = 0.004) suggests that an increase in VRES has a small but statistically significant immediate downward impact on control costs. Conversely, the positive coefficients at lags 4, 5, and 6 indicate that VRES fluctuations at earlier periods can lead to a subsequent rise in control costs. Overall, the F-statistic for this equation (978.4, p < 2.2e-16) and adjusted R-squared of 0.2723 suggest that the model explains a moderate portion of the variability in control costs, with a strong relationship captured over the 10 lags.

For the equation predicting VRES (VRES_log_seasonal_diff), most of the significant effects are driven by the variable's own lags, rather than control costs. VRES is highly influenced by its own history, with significant coefficients at many lags (1, 2, 3, 4, 5, and others), demonstrating the strong autocorrelation and persistence in renewable energy generation patterns. Control costs do not appear to significantly influence VRES, with only a few lags (such as lag 9 and 10) showing significant coefficients. The adjusted R-squared of 0.05423 for the VRES equation suggests that other factors, not captured in this model, likely explain the majority of the variation in VRES. The overall low correlation (0.001467) between the residuals of the two equations further confirms that VRES and control costs have a relatively low degree of direct correlation in the residual unexplained portions of the time series. Overall, the results imply that while VRES has a measurable impact on control costs, control costs have little reciprocal effect on VRES generation.

### 3.8. Granger Causality Test of VRES Impact on Total Control Costs

To further investigate the causal relationship between VRES  and control costs, a Granger causality test will be conducted. This test is designed to determine whether past values of one time series can help predict future values of another. Specifically, it will assess whether changes in VRES "Granger-cause" variations in control costs. By applying this test, we can determine if VRES has a predictive influence on control costs beyond their own historical patterns, solidifying the insights gained from the VAR model. This will provide a more in-depth understanding of the interactions between renewable energy penetration and grid operation costs.

```{r, granger, echo = TRUE, warning = FALSE}
# Perform Granger causality
causality(var_model, cause = "VRES_log_seasonal_diff")

```

The results of the Granger causality test provide strong evidence that VRES Granger-cause changes in control costs. The F-test statistic of 4.8896, with a very low p-value, allows us to confidently reject the null hypothesis that VRES does not Granger-cause control costs. This means that past values of VRES have predictive power over future variations in control costs, suggesting that fluctuations in renewable energy penetration directly influence the costs of maintaining grid stability. This reinforces the findings from the VAR model, where certain lags of VRES were found to have significant effects on control costs. However, the test for instantaneous causality between VRES and control costs yields a Chi-squared statistic of 0.11246 and a p-value of 0.7374, indicating no significant evidence of instantaneous causality between the two variables. In summary, VRES has a predictive, lagged impact on control costs, but the relationship is not instantaneous, highlighting the importance of considering the delayed effects of renewable energy integration on grid operation expenses.

# 4. Time Series of Daily Benchmark Data
## Daily VRES and non-VRES Production

This chapter deals with the benchmark data of daily VRES production and day-ahead prices.

### 4.1. Visualization of Daily VRES and non-VRES Production

```{r, sun and wind visualization, eval = F, echo = FALSE, warning = F}

ggplot(d.d %>%
         select(Date, Photovoltaic_GWh, Wind_GWh) %>%
         pivot_longer(cols = c(Photovoltaic_GWh, Wind_GWh), 
                      names_to = "Source", 
                      values_to = "GWh"), 
       aes(x = as.Date(Date), y = GWh, color = Source)) +
  geom_line(size = 1) +
  labs(title = "Time Series of Photovoltaic and Wind Energy Production",
       x = NULL, y = "Energy Production (GWh)") +
  scale_color_manual(values = c("Photovoltaic_GWh" = "orange", "Wind_GWh" = "darkgrey")) +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")
```

The first graph illustrates the evolution of photovoltaic and wind energy production over time. Photovoltaic production (in orange) exhibits a clear seasonal pattern, with higher output during the summer months and lower production in winter, reflecting the natural variation in solar energy availability. In contrast, Wind production (in grey) remains consistently low throughout the year with some fluctuations but no clear trend, indicating that wind energy may play a relatively small role in the overall energy production mix compared to photovoltaic energy.

```{r, vres visualization, eval = F, echo = FALSE, warning = F}

ggplot(d.d %>%
         select(Date, VRES_GWh, Non_VRES_GWh) %>%
         pivot_longer(cols = c(VRES_GWh, Non_VRES_GWh), 
                      names_to = "Source", 
                      values_to = "GWh"), 
       aes(x = as.Date(Date), y = GWh, color = Source)) +
  geom_line(size = 1) +
  labs(title = "Time Series of VRES and Non-VRES Production",
       x = NULL, y = "Energy Production (GWh)") +
  scale_color_manual(values = c("VRES_GWh" = "darkgreen", "Non_VRES_GWh" = "black")) +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")
```

The second graph compares VRES (Variable Renewable Energy Sources, including Photovoltaic and Wind) with Non-VRES (comprising Hydro, Nuclear, Storage, and Thermal energy). The Non-VRES sources (in black) dominate total energy production and display significant variability over time, driven by factors such as fluctuating demand and adjustments in non-renewable energy generation. VRES production (in green), while much lower in magnitude, shows a clear seasonal trend, largely driven by photovoltaic energy, with peaks in the summer months.

### 4.2. Decomposition of Daily VRES Production

```{r, decomposition, eval = F, echo = FALSE, warning = F}
# Create a time series object for VRES production (Photovoltaic + Wind)
vres_ts_d <- ts(d.d$VRES_GWh, start = c(2017, 1), frequency = 365)

# Decompose the VRES time series
vres_decomp_d <- decompose(vres_ts_d)
plot(vres_decomp_d, xlab = NULL)

# Check the first few values of each component
head(vres_decomp_d$trend)
head(vres_decomp_d$seasonal)
head(vres_decomp_d$random)
```

The decomposition reveals a clear linear trend and strong seasonal patterns, with some variability in both the seasonal component and residuals. While the seasonal noise is expected due to the nature of renewable energy sources like photovoltaic and wind, it does not obscure the overall pattern. The fluctuations in the residuals suggest potential volatility of variance, but this can be addressed by examining the residuals further after modeling.

### 4.3. Stationarity of Daily VRES Production

As in previous steps, we apply a log-transformation as well as regular differencing to remove the linear trend and since there is seasonality, we also apply seasonal differencing.

```{r, differencing vres, eval = F, echo = FALSE, warning = F}
# Apply log transformation (add a small constant to avoid log(0) issues)
vres_log_d <- log(vres_ts_d + 1e-6)

# Apply first-order differencing to the log-transformed series
vres_log_diff_d <- diff(vres_log_d)

# Apply seasonal differencing
vres_log_seasonal_diff_d <- diff(vres_log_diff_d, lag = 365)
sum(is.na(vres_log_seasonal_diff_d))

plot(vres_log_seasonal_diff_d, main="Log-Transformed and Seasonally Differenced VRES Time Series", 
     ylab = "Differenced GWh", 
     xlab = NULL)

```

```{r, decomposition vres, eval = F, echo = FALSE, warning = F}
# Decomposition of fully differenced time series 
vres_log_seasonal_diff_d_decomp <- decompose(vres_log_seasonal_diff_d)
plot(vres_log_seasonal_diff_d_decomp)
```

```{r, vres stationarity, eval = F, echo = TRUE, warning = TRUE}
# Perform ADF test to check stationarity
adf.test(vres_log_seasonal_diff_d)
```

The first plot presents the fully differenced series, which now fluctuates around a constant mean with reduced variance, indicating a more stable time series. The decomposition in the second plot confirms that both trend and seasonal components have been largely removed, leaving the random component as the main driver of variability. The results of the Augmented Dickey-Fuller (ADF) test confirm the stationarity of the differenced time series, with a Dickey-Fuller test statistic of -22.628 and a p-value smaller than 0.01, allowing us to reject the null hypothesis of non-stationarity. With the series now stationary, it is ready for further analysis

### 4.4. Forecast of Daily VRES Production

After confirming the stationarity of the VRES daily time series, we proceeded with analyzing its Autocorrelation Function (ACF) and Partial Autocorrelation Function (PACF). The ACF plot (first image) reveals that after the first lag, the autocorrelations drop off quickly and remain within the confidence bounds, suggesting limited autocorrelation beyond the immediate past values. This indicates that the series does not exhibit strong long-term memory, and most of the autocorrelation is explained by the first few lags.

```{r, daily vres acf pacf, eval = F, echo = FALSE, warning = F}
# ACF and PACF for the log-transformed differenced series
acf(vres_log_seasonal_diff_d)
pacf(vres_log_seasonal_diff_d)
```

The PACF plot (second plot) shows a more gradual decline with significant negative partial autocorrelations up to lags beyond lag 10. This behavior suggests that a few past observations have a direct influence on the current value. We will now proceed with the SARIMA forecast.

```{r, daily vres_sarima model, eval = F, echo = FALSE, warning = F}

# Fit a SARIMA model with auto.arima to handle seasonality
sarima_model <- auto.arima(vres_ts_d, seasonal = TRUE)

# Summary of the fitted model
summary(sarima_model)

```

The fitted SARIMA(3,1,1)(0,1,0)[365] model effectively captures both short-term and seasonal patterns in the VRES time series. The significant autoregressive terms (especially AR1 at 0.3929) and the large negative moving average term (MA1 at -0.9766) indicate that recent past values and residuals from previous periods strongly influence future VRES values. The model shows a good fit with a sigma² of 7.477 and low residual autocorrelation (ACF1 = 0.0009), suggesting that most of the autocorrelation has been captured.

The residual analysis (plot below) further supports the model's adequacy: the residuals appear randomly distributed around zero, the ACF plot of residuals shows significant autocorrelations at the year mark, and the residuals’ histogram closely follows a normal distribution. Error metrics, including an RMSE of 2.547 and MAPE of 27.52%, indicate moderate forecasting accuracy, while the AIC (11819.13) and BIC (11848.12) confirm the model's parsimony. Overall, this SARIMA model provides a good balance between capturing seasonal trends and ensuring predictive accuracy.

```{r, sarima residuals, eval = F, echo = FALSE, warning = F}

# Check residuals of the SARIMA model
checkresiduals(sarima_model)

```

The SARIMA forecast visualization below provides an outlook for VRES energy production over the next two years, continuing from the historical data. The forecast shows a continuation of the established seasonal patterns, with recurring peaks and troughs that align with the cyclical nature of renewable energy production. The forecasted values exhibit an expected upward trend in energy production, consistent with recent years, indicating a gradual increase in VRES generation. The shaded area around the forecast line represents the prediction intervals, with wider bands toward the end of the forecast horizon, reflecting increased uncertainty as we look further into the future.

```{r, sarima plot, eval = F, echo = FALSE, warning = F}

# Forecast the next years
sarima_forecast <- forecast(sarima_model, h = 730)

# Plot the forecast
#plot(sarima_forecast, main="SARIMA Forecast for VRES Time Series")

# Visualize the SARIMA forecast with confidence intervals
autoplot(sarima_forecast) +
  ggtitle("SARIMA Forecast for VRES Time Series") +
  xlab("Date") +
  ylab("Energy Production (GWh)")
```


## Daily Data of Day-Ahead Prices of Baseload
### 4.5. Visualization of Day-Ahead Prices

We now would like to turn our attention to the baseload energy prices in EUR/MWh over time. From 2017 through most of 2021, prices remained relatively stable, fluctuating within a narrow range with occasional spikes. However, from the end of 2021 through 2023, there is a sharp and sustained increase in energy prices, with peaks exceeding 600 EUR/MWh and increased volatility. This surge is likely driven by exogenous factors, including the geopolitical tensions and market disruptions we previously identified. After mid-2023, prices gradually return to lower levels but still exhibit heightened volatility compared to pre-2021 levels. This period of extreme price fluctuations highlights the sensitivity of energy markets to external shocks.

```{r, day-ahead baseload: plot of day-ahead, eval = F, echo = FALSE, warning = F}

# Create a line plot of Baseload_EUR_MWh over time
ggplot(d.d, aes(x = as.Date(Date), y = Baseload_EUR_MWh)) +
  geom_line(color = "darkblue", size = 0.5) +
  labs(title = "Baseload Energy Prices Over Time",
       x = NULL, 
       y = "Baseload (EUR/MWh)") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")

```

### 4.6. Decomposition of Day-Ahead Prices

```{r, day-ahead baseload_decomposition, eval = F,  echo = FALSE, warning = F}
# Convert the Baseload_EUR_MWh column to a time series object
# Assuming daily data, we set frequency = 365 for yearly seasonality
baseload_ts <- ts(d.d$Baseload_EUR_MWh, start = c(2017, 1), frequency = 365)

# Decompose the time series into trend, seasonal, and random components
decomp_baseload <- decompose(baseload_ts)

# Plot the decomposition
plot(decomp_baseload)

```

### 4.7. Stationarity of Day-Ahead Prices

```{r, day-ahead baseload_differencing 1, eval = F, echo = FALSE, warning = F}
# Apply first-order differencing to remove the trend
diff_baseload_ts <- diff(baseload_ts, differences = 1)

# Plot the differenced series
plot(diff_baseload_ts, main="Differenced Baseload Time Series")

# Apply seasonal differencing (assuming yearly seasonality with a frequency of 365)
seasonal_diff_baseload_ts <- diff(diff_baseload_ts, lag = 365)

# Plot the seasonally differenced series
plot(seasonal_diff_baseload_ts, main="Seasonally Differenced Baseload Time Series")

```

```{r, day-ahead baseload_differencing 2, eval = F, echo = FALSE, warning = F}
# Apply log transformation (add a small constant to avoid log(0) issues)
baseload_log_d <- log(baseload_ts + 1e-6)

# Apply first-order differencing to the log-transformed series
baseload_log_diff_d <- diff(baseload_log_d)

# Apply seasonal differencing
baseload_log_seasonal_diff_d <- diff(baseload_log_diff_d, lag = 365)
sum(is.na(baseload_log_seasonal_diff_d))

plot(baseload_log_d, 
     main="Log-Transformed and Seasonally Differenced Baseload Time Series", 
     ylab = "Differenced EUR", 
     xlab = NULL)

```

```{r, day-ahead baseload_adf, eval = F, echo = FALSE, warning = F}
# Perform ADF test to check stationarity
adf.test(baseload_log_seasonal_diff_d)
```

#### 4.8. Forecast of Day-Ahead Prices

```{r, plot of day-ahead, eval = F, echo = FALSE, warning = F}
# Fit SARIMA model using auto.arima
sarima_model_baseload <- auto.arima(baseload_ts, seasonal = TRUE)

# Summary of the fitted SARIMA model
summary(sarima_model_baseload)

# Forecast the next period
sarima_forecast_baseload <- forecast(sarima_model_baseload, h = 100)

# Visualize the SARIMA forecast with confidence intervals
autoplot(sarima_forecast_baseload) +
  ggtitle("SARIMA Forecast for Baseload Time Series") +
  xlab("Date") +
  ylab("Baseload (EUR)")
```

# Results

## Limitations

-cover general limitations

# Conclusion

What did we learn, what did we not learn, how does this relate to policymakers.

\newpage

# Biblioghraphy
